{
	"camera" : 
	{
		"center" : "0.00000 0.00000 -1.00000",
		"eye" : "0.00000 0.00000 0.00000",
		"up" : "0.00000 1.00000 0.00000"
	},
	"general" : 
	{
		"ambientcolor" : "0.30000 0.30000 0.30000",
		"bloom" : false,
		"bloomhdrfeather" : 0.10000000149011612,
		"bloomhdrscatter" : 1.6189999580383301,
		"bloomhdrstrength" : 2.0,
		"bloomhdrthreshold" : 1.0,
		"bloomstrength" : 2.0,
		"bloomthreshold" : 0.64999997615814209,
		"camerafade" : true,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.5,
		"cameraparallaxdelay" : 0.10000000149011612,
		"cameraparallaxmouseinfluence" : 0.0,
		"camerapreview" : true,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.25098 0.53333 0.97255",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 50.0,
		"hdr" : false,
		"nearz" : 0.0099999997764825821,
		"orthogonalprojection" : 
		{
			"height" : 1080,
			"width" : 1920
		},
		"skylightcolor" : "0.30000 0.30000 0.30000",
		"zoom" : 1.0
	},
	"objects" : 
	[
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 7,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGHelpers (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nlet bEnableDebugText = true;\nlet debugText_Layers = [];\nlet debugText_FlashColor = new Vec3(0.5, 1.0, 1.0);\nlet debugText_Color = new Vec3(1.0, 1.0, 1.0);\nlet debugText_Size = 12;\nlet debugText_Alpha = 0.75;\nlet debugText_FlashScale = 1.01;\n/** How many milliseconds to fade from the flash color to the normal \n * \tcolor when the text is updated. */\nlet debugText_FlashTime = 250;\n/** How many milliseconds to display the text before starting to fade out. */\nlet debugText_StickTime = 500;\n/** How many milliseconds to fade out the debug text before removing it. */\nlet debugText_FadeTime = 1500;\n\nexport function update() {\n\tlet currentTime = new Date().getTime();\n\tdebugText_Layers.forEach(\n\t\tfunction(textLayer, index, array) {\n\t\t\tif (currentTime > textLayer.lastUpdated + (debugText_StickTime + debugText_FadeTime)) {\n\t\t\t\ttextLayer.alpha = 0;\n\t\t\t\tthisScene.destroyLayer(textLayer);\n\t\t\t\tarray.splice(index, 1);\n\t\t\t}\n\t\t\telse if (currentTime > textLayer.lastUpdated + debugText_StickTime) {\n\t\t\t\ttextLayer.color = debugText_Color;\n\t\t\t\tlet fadeLerp = (currentTime - (textLayer.lastUpdated + debugText_StickTime)) / debugText_FadeTime;\n\t\t\t\ttextLayer.alpha = OMGHelpers.lerp(debugText_Alpha, 0, fadeLerp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet flashLerp = OMGHelpers.clamp((currentTime - textLayer.lastChanged) / debugText_FlashTime);\n\t\t\t\ttextLayer.color = OMGHelpers.lerp(debugText_FlashColor, debugText_Color, flashLerp);\n\t\t\t\ttextLayer.scale = new Vec3(OMGHelpers.lerp(debugText_FlashScale, 1, flashLerp));\n\t\t\t\ttextLayer.alpha = debugText_Alpha;\n\t\t\t}\n\t\t\ttextLayer.origin = new Vec3(0, engine.canvasSize.y - index * (debugText_Size * 3 + 10), 0);\n\t\t\ttextLayer.visible = bEnableDebugText;\n\t\t}\n\t);\n}\n\nclass OMGHelpers {\n\t/** Prints all key/value pairs present on the object to the console. */\n\tstatic printObjectValues(obj){\n\t\tif (typeof(obj) !== 'object' || obj === null)\n\t\t\treturn;\n\n\t\tlet keys = Object.keys(obj);\n\t\tfor (let i = 0; i < keys.length; ++i)\n\t\t\tconsole.log(keys[i] + \" - \" + obj[keys[i]]);\n\t}\n\n\t/** Attempts to add two values together. */\n\tstatic add(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 + v2;\n\t\telse if (v1.add)\n\t\t\treturn v1.add(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to subtract the second value from the first value. */\n\tstatic subtract(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 - v2;\n\t\telse if (v1.subtract)\n\t\t\treturn v1.subtract(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to multiply two values together. */\n\tstatic multiply(v1, v2) {\n\t\tif (v2 === undefined)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to divide the first value by the second value. */\n\tstatic divide(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Restricts a value to remain between two boundary values. \n\t * @param {number} val - The value to be restricted.\n\t * @param {number} min - The lower bound.\n\t * @param {number} max - The upper bound.\n\t*/\n\tstatic clamp(val, min = 0, max = 1) {\n\t\tswitch (typeof val) {\n\t\tcase \"number\":\n\t\t\treturn Math.min(max, Math.max(min, val));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/** Interpolate linearly from the first value to the second based on the third (0 to 1) */\n\tstatic lerp(v1, v2, percent) {\n\t\tif (typeof(v1) === \"number\")\n\t\t\treturn v1 + (v2 - v1) * percent;\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (v1 instanceof Vec3) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (v1 instanceof Vec4) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\tlet w = v1.w + (v2.w - v1.w) * percent;\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Prints a stack trace to the console. */\n\tstatic stackTrace() {\n\t\treturn console.log(new Error().stack);\n\t}\n\t\n\t/** Creates or updates a text layer in the corner of the screen. \n\t * @param {string} name - The name of the text layer to create or update.\n\t * @param {string} text - The text that the layer should display.\n\t*/\n\tstatic debugText(name, text) {\n\t\tif (bEnableDebugText && name !== undefined && text !== undefined) {\n\t\t\tlet layer = thisScene.getLayer(name.toString());\n\t\t\tif (layer) {\n\t\t\t\tif (layer.text != text) {\n\t\t\t\t\tlayer.text = text;\n\t\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\t\tlayer.color = debugText_FlashColor;\n\t\t\t\t\tlayer.scale = new Vec3(debugText_FlashScale);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlayer.lastUpdated = new Date().getTime();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet layerSettings = new Object();\n\t\t\t\tlayerSettings.name = name.toString();\n\t\t\t\tlayerSettings.text = text;\n\t\t\t\tlayerSettings.pointsize = debugText_Size;\n\t\t\t\tlayerSettings.font = \"systemfont_consolas\";\n\t\t\t\tlayerSettings.origin = \"0, \" + (engine.canvasSize.y - debugText_Layers.length * (debugText_Size * 3 + 10)) + \", 0\";\n\t\t\t\tlayerSettings.verticalalign = \"top\";\n\t\t\t\tlayerSettings.horizontalalign = \"left\";\n\t\t\t\tlayerSettings.color = debugText_FlashColor.x + \", \" + debugText_FlashColor.y + \", \" + debugText_FlashColor.z;\n\t\t\t\tlayerSettings.alpha = debugText_Alpha;\n\t\t\t\tlayer = thisScene.createLayer(layerSettings)\n\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\tdebugText_Layers.push(layer);\n\t\t\t}\n\t\t}\n\t}\n}\n\nshared.OMGHelpers = OMGHelpers;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 9,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGMatrix (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n// matrix functions referenced from https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js\n\nconst deg2rad = Math.PI / 180;\nconst rad2deg = 180 / Math.PI;\n\nfunction clamp(x, min, max){ return Math.max(Math.min(x, max), min) }\n\nclass Mat4 {\n\tconstructor(b){\n\t\tif (b instanceof Mat4){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = b.elements[i].slice();\n\t\t\t}\n\t\t}\n\t\telse if (arguments.length === 16){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = new Array(4);\n\t\t\t\tfor(let j = 0; j < 4; j++){\n\t\t\t\t\tthis.elements[i][j] = arguments[i*4 + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tthis.elements = [\n\t\t\t\t[1, 0, 0, 0],\n\t\t\t\t[0, 1, 0, 0],\n\t\t\t\t[0, 0, 1, 0],\n\t\t\t\t[0, 0, 0, 1]\n\t\t\t];\n\t\t}\n\t}\n\n\n\tprintElements(){\n\t\tfor(let x = 0; x < 4; x++){\n\t\t\tlet line = \"\";\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tline += this.elements[x][y].toString() + \" \";\n\t\t\t}\n\t\t\tconsole.log(line);\n\t\t}\n\t}\n\n\n\tmultiply(right){\n\t\tlet a = this.elements;\n\t\tlet b = right.elements;\n\t\tlet r = new Mat4();\n\n\t\tfor (let x = 0; x < 4; x++){\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tr.elements[x][y] = a[x][0] * b[0][y] + a[x][1] * b[1][y] + a[x][2] * b[2][y] + a[x][3] * b[3][y];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\n\tstatic fromAxisAngle(axis, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\tlet t = 1 - cos;\n\t\tlet x = axis.x, y = axis.y, z = axis.z;\n\t\tlet tx = t*x, ty = t*y;\n\n\t\treturn new Mat4(\n\t\t\ttx * x + cos,      tx * y - sin * z,  tx * z + sin * y,  0,\n\t\t\ttx * y + sin * z,  ty * y + cos,      ty * z - sin * x,  0,\n\t\t\ttx * z - sin * y,  ty * z + sin * x,  t * z * z + cos,   0,\n\t\t\t0,                 0,                 0,                 1\n\t\t);\n\t}\n\n\n\tstatic fromPosition(pos){\n\t\treturn new Mat4(\n\t\t\t1, 0, 0, pos.x,\n\t\t\t0, 1, 0, pos.y,\n\t\t\t0, 0, 1, pos.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\t}\n\n\n\ttoPosition(){\n\t\tlet m = this.elements;\n\t\treturn new Vec3(m[0][3], m[1][3], m[2][3]);\n\t}\n\n\n\tstatic fromEuler(angles, order){\n\t\tlet r = new Mat4();\n\t\tlet e = angles.multiply(deg2rad);\n\t\tlet sx = Math.sin(e.x), sy = Math.sin(e.y), sz = Math.sin(e.z);\n\t\tlet cx = Math.cos(e.x), cy = Math.cos(e.y), cz = Math.cos(e.z);\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = -cy * sz;\n\t\t\t\tr.elements[0][2] = sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz + sx * cz * sy;\n\t\t\t\tr.elements[1][1] = cx * cz - sx * sz * sy;\n\t\t\t\tr.elements[1][2] = -sx * cy;\n\n\t\t\t\tr.elements[2][0] = sx * sz - cx * cz * sy;\n\t\t\t\tr.elements[2][1] = sx * cz + cx * sz * sy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YXZ\":\n\t\t\t\tr.elements[0][0] = cy * cz + sy * sz * sx;\n\t\t\t\tr.elements[0][1] = sy * cz * sx - cy * sz;\n\t\t\t\tr.elements[0][2] = cx * sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx;\n\n\t\t\t\tr.elements[2][0] = cy * sz * sx - sy * cz;\n\t\t\t\tr.elements[2][1] = sy * sz + cy * cz * sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZXY\":\n\t\t\t\tr.elements[0][0] = cy * cz - sy * sz * sx\n\t\t\t\tr.elements[0][1] = -cx * sz;\n\t\t\t\tr.elements[0][2] = sy * cz + cy * sz * sx;\n\n\t\t\t\tr.elements[1][0] = cy * sz + sy * cz * sx;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = sy * sz - cy * cz * sx;\n\n\t\t\t\tr.elements[2][0] = -cx * sy;\n\t\t\t\tr.elements[2][1] = sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZYX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * cz * sy - cx * sz;\n\t\t\t\tr.elements[0][2] = cx * cz * sy + sx * sz;\n\n\t\t\t\tr.elements[1][0] = cy * sz;\n\t\t\t\tr.elements[1][1] = sx * sz * sy + cx * cz;\n\t\t\t\tr.elements[1][2] = cx * sz * sy - sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy;\n\t\t\t\tr.elements[2][1] = sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YZX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * sy - cx * cy * sz;\n\t\t\t\tr.elements[0][2] = sx * cy * sz + cx * sy;\n\n\t\t\t\tr.elements[1][0] = sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy * cz;\n\t\t\t\tr.elements[2][1] = cx * sy * sz + sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy - sx * sy * sz;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// right colur.elementsn\n\t\tr.elements[0][3] = 0;\n\t\tr.elements[1][3] = 0;\n\t\tr.elements[2][3] = 0;\n\t\t\n\t\t// bottor.elements row\n\t\tr.elements[3][0] = 0;\n\t\tr.elements[3][1] = 0;\n\t\tr.elements[3][2] = 0;\n\t\tr.elements[3][3] = 1;\n\n\t\treturn r;\n\t}\n\n\n\ttoEuler(order){\n\t\tlet m = this.elements;\n\t\tlet x,y,z;\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\ty = Math.asin(clamp(m[0][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][2] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YXZ\":\n\t\t\t\tx = Math.asin(-clamp(m[1][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][2] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZXY\":\n\t\t\t\tx = Math.asin(clamp(m[2][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][1] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZYX\":\n\t\t\t\ty = Math.asin(-clamp(m[2][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YZX\":\n\t\t\t\tz = Math.asin(clamp(m[1][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[1][1]);\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"XZY\":\n\t\t\t\tz = Math.asin(-clamp(m[0][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][1] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\ty = Math.atan2(m[0][2], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tlet euler = new Vec3(x, y, z);\n\t\teuler = euler.multiply(rad2deg);\n\t\treturn euler;\n\t}\n\n\tstatic fromScale(s) {\n\t\treturn new Mat4(\n\t\t\ts.x, 0,   0,   0,\n\t\t\t0,   s.y, 0,   0,\n\t\t\t0,   0,   s.z, 0,\n\t\t\t0,   0,   0,   1\n\t\t);\n\t}\n\n\ttoScale() {\n\t\tlet m = this.elements;\n\t\treturn new Vec3(\n\t\t\tMath.sqrt(m[0][0]*m[0][0] + m[0][1]*m[0][1] + m[0][2]*m[0][2]),\n\t\t\tMath.sqrt(m[1][0]*m[1][0] + m[1][1]*m[1][1] + m[1][2]*m[1][2]),\n\t\t\tMath.sqrt(m[2][0]*m[2][0] + m[2][1]*m[2][1] + m[2][2]*m[2][2])\n\t\t);\n\t}\n};\n\nshared.Mat4 = Mat4;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 10,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGVector (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nclass OMGVector {\n\t/**\n\t * @param {Vec3} vector\n\t * @param {Number} angle\n\t * Rotates the vector in radians around the X axis\n\t */\n\tstatic rotX(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x, \n\t\t\tvector.y * cos - vector.z * sin,\n\t\t\tvector.y * sin + vector.z * cos)\n\t};\n\n\tstatic rotY(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos + vector.z * sin,\n\t\t\tvector.y, \n\t\t\t-vector.x * sin + vector.z * cos)\n\t};\n\n\tstatic rotZ(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos - vector.y * sin,\n\t\t\tvector.x * sin + vector.y * cos,\n\t\t\tvector.z)\n\t};\n\n\tstatic rotAxis(vec, angle, axis){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\t(cos + (1 - cos) * axis.x * axis.x) * vec.x +\n\t\t\t((1 - cos) * axis.x * axis.y - axis.z * sin) * vec.y +\n\t\t\t((1 - cos) * axis.x * axis.z + axis.y * sin) * vec.z,\n\n\t\t\t((1 - cos) * axis.x * axis.y + axis.z * sin) * vec.x +\n\t\t\t(cos + (1 - cos) * axis.y * axis.y) * vec.y +\n\t\t\t((1 - cos) * axis.y * axis.z - axis.x * sin) * vec.z,\n\n\t\t\t((1 - cos) * axis.x * axis.z - axis.y * sin) * vec.x +\n\t\t\t((1 - cos) * axis.y * axis.z + axis.x * sin) * vec.y +\n\t\t\t(cos + (1 - cos) * axis.z * axis.z) * vec.z\n\t\t);\n\t};\n\n\tstatic rotVec(vector, angles){\n\t\tlet r = rotX(vector, angles.x);\n\t\tr = rotY(r, angles.y);\n\t\treturn r = rotZ(r, angles.z);\n\t};\n\n\tstatic unrotVec(vector, angles){\n\t\tlet r = rotZ(vector, -angles.x);\n\t\tr = rotY(r, -angles.y);\n\t\treturn r = rotX(r, -angles.z);\n\t};\n\n\tstatic forwardY(angles){\n\t\treturn rotVec(new Vec3(0., 1., 0.), angles);\n\t};\n\n\tstatic forwardZ(angles){\n\t\treturn rotVec(new Vec3(0., 0., 1.), angles);\n\t};\n\n\tstatic forwardX(angles){\n\t\treturn rotVec(new Vec3(1., 0., 0.), angles);\n\t};\n\n\tstatic interpAngle(angle1, angle2, percent){\n\t\tlet a1 = [angle1.x % 360, angle1.y % 360, angle1.z % 360];\n\t\tlet a2 = [angle2.x % 360, angle2.y % 360, angle2.z % 360];\n\t\tlet diff = [];\n\t\tfor (let i = 0; i < 3; i++){\n\t\t\tif (a1[i] < 0)\n\t\t\t\ta1[i] += 360;\n\t\t\tif (a2[i] < 0)\n\t\t\t\ta2[i] += 360;\n\t\t\tdiff[i] = a2[i] - a1[i];\n\t\t\tif (diff[i] > 180)\n\t\t\t\tdiff[i] -= 360;\n\t\t\telse if (diff[i] < -180)\n\t\t\t\tdiff[i] += 360;\n\t\t}\n\t\treturn new Vec3(a1[0] + diff[0] * percent, a1[1] + diff[1] * percent, a1[2] + diff[2] * percent);\n\t};\n\n\tstatic interpPosition(pos1, pos2, percent){\n\t\treturn lerp(pos1, pos2, percent);\n\t}\n\n\t/**\n\t * Interpolates linearly between v1 and v2 based on percent (0 to 1).\n\t * @param {Vec3} v1 First vector\n\t * @param {Vec3} v2 Second vector\n\t * @param {Number} percent interpolation value between 0 and 1\n\t */\n\tstatic lerp(v1, v2, percent){\n\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\treturn new Vec3(x, y, z);\n\t};\n\t\n\n\tstatic magnitude(vec){\n\t\treturn Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n\t}\n\n\tstatic normalize(vec){\n\t\treturn vec.multiply(1 / OMGVector.magnitude(vec));\n\t};\n\n\t/**\n\t * True if the two vectors contain equal x, y, and z values, otherwise false\n\t * @param [epsilon] {number} The minimum difference allowed between vector values before they are considered non-equal (helps avoid some floating-point issues)\n\t * @return {boolean}\n\t */\n\tstatic equal(v1, v2, epsilon = 0.0001){\n\t\tif (epsilon)\n\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v1.z) < epsilon);\n\t\telse\n\t\t\treturn (v1.x === v2.x && v1.y === v2.y && v1.z === v1.z);\n\t}\n}\n\nshared.OMGVector = OMGVector;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 11,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "LayerParenting (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\nconst Mat4 = shared.Mat4;\nconst OMGVector = shared.OMGVector;\n\nexport function init() { \n\t// Create a simple dummy layer for the root node.\n\t_rootNode.layerID = thisScene.getLayerIndex(thisScene.createLayer({\n\t\tname: \"root\",\n\t\tsound: [],\n\t\t}));\n}\nexport function update() { LayerParenting.update(); }\n\n\n/**\n * Bitwise flags representing the properties of the parent layer which should be inherited.\n * @enum {number} \n */\nconst PARENTFLAG = {\n\tPOSITION   : 1 << 0,\n\tROTATION   : 1 << 1,\n\tSCALE      : 1 << 2,\n\tVISIBILITY : 1 << 3,\n\tALL        : ~0\n}\n\n\n/** \n * Contains references to every non-root node, indexed by layer ID.\n * @type Object.<number, LayerTreeNode>\n */\nlet _treeDirectory = {};\n\n/** \n * Root node for the scene. Any children of this node effectively have no parent.\n * @type {LayerTreeNode}\n */\nlet _rootNode = undefined; // gets defined after LayerTreeNode's definition.\n\n/** \n * Node in the layer tree which represents a layer and its relationship to any child layers. \n */\nclass LayerTreeNode {\n/** \n * @typedef LayerTreeNodeParams {Object} \n * @property layerID {number} - The ID of the layer represented by this node.\n * @property [parentNode] {LayerTreeNode} - This node's parent.\n * @property [parentFlags] {PARENTFLAG} - An optional set of flags enabling or disabling parenting of various layer attributes.\n * @property [position] {Vec3} - The layer's translational offset from the parent.\n * @property [rotation] {Vec3} - The layer's local rotation in degrees.\n * @property [scale] {Vec3} - The layer's scale.\n */\n\t/** \n\t * @param params {LayerTreeNodeParams} - Object which enables parameters to be set by name rather than by sequence. \n\t */\n\tconstructor(params = {}){\n\t\tthis.layerID = params.layerID;\n\t\tthis.parentNode = params.parentNode || _rootNode;\n\t\tif (this.parentNode !== undefined) // Will be undefined when creating _rootNode\n\t\t\tthis.parentNode.addChild(this);\n\t\tif (params.parentFlags !== undefined)\n\t\t\tthis.parentFlags = params.parentFlags;\n\t\telse\n\t\t\tthis.parentFlags = PARENTFLAG.ALL;\n\t\t\n\t\t/** @type LayerTreeNode[] */\n\t\tthis.children = [];\n\t\t\n\t\tthis._position = params.position || new Vec3(0, 0, 0);\n\t\tthis._positionMatrix = new Mat4();\n\t\tthis._positionChanged = true;\n\n\t\tthis._rotation = params.rotation || new Vec3(0, 0, 0);\n\t\tthis._rotationMatrix = new Mat4();\n\t\tthis._rotationChanged = true;\n\t\t\n\t\tthis._scale = params.scale || new Vec3(1, 1, 1);\n\t\tthis._scaleMatrix = new Mat4();\n\t\tthis._scaleChanged = true;\n\n\t\tthis._localTransform = new Mat4();\n\t\tthis._localTransformChanged = true;\n\t\t\n\t\t_treeDirectory[this.layerID] = this;\n\t}\n\t\n\t/**\n\t * Removes this node from the tree.\n\t */\n\tdestruct() {\n\t\tremoveChildren();\n\t\tthis.parentNode.removeChild(this);\n\t\tdelete _treeDirectory[this.layerID];\n\t\treturn null;\n\t}\n\n\tget layer() { return thisScene.getLayer(this.layerID); }\n\tget name() { return this.layer.name; }\n\n\t/** @return {Vec3} */\n\tget position() { return this._position; }\n\tset position(newPos) {\n\t\tif (newPos instanceof Vec3) {\n\t\t\tthis._position = newPos;\n\t\t\tthis._positionChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newPos;\n\t}\n\tget positionMatrix() {\n\t\tif (this._positionChanged) {\n\t\t\tthis._positionMatrix = Mat4.fromPosition(this._position);\n\t\t\tthis._positionChanged = false;\n\t\t}\n\t\treturn this._positionMatrix;\n\t}\n\n\n\t/** @return {Vec3} */\n\tget rotation() { return this._rotation; }\n\tset rotation(newRot) {\n\t\tif (newRot instanceof Vec3) {\n\t\t\tthis._rotation = newRot;\n\t\t\tthis._rotationChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newRot;\n\t}\n\tget rotationMatrix() {\n\t\tif (this._rotationChanged) {\n\t\t\tthis._rotationMatrix = Mat4.fromEuler(this._rotation, \"XYZ\");\n\t\t\tthis._rotationChanged = false;\n\t\t}\n\t\treturn this._rotationMatrix;\n\t}\n\n\t/** @return {Vec3} */\n\tget scale() { return this._scale; }\n\tset scale(newScale) {\n\t\tif (newScale instanceof Vec3) {\n\t\t\tthis._scale = newScale;\n\t\t\tthis._scaleChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newScale;\n\t}\n\tget scaleMatrix() {\n\t\tif (this._scaleChanged) {\n\t\t\tthis._scaleMatrix = Mat4.fromScale(this._scale);\n\t\t\tthis._scaleChanged = false;\n\t\t}\n\t\treturn this._scaleMatrix;\n\t}\n\n\t/** The local offset from the paren't axis/origin */\n\tget localTransform() {\n\t\tif (this._localTransformChanged) {\n\t\t\tthis._localTransform = (\n\t\t\t\tthis.positionMatrix.multiply(\n\t\t\t\tthis.rotationMatrix.multiply(\n\t\t\t\tthis.scaleMatrix\n\t\t\t)));\n\t\t\tthis._localTransformChanged = false;\n\t\t}\n\t\treturn this._localTransform;\n\t}\n\n\t/**\n\t * @return {Mat4} The final transformation matrix for this node \n\t */\n\tget worldTransform() {\n\t\tif (!(this.parentFlags & (PARENTFLAG.POSITION | PARENTFLAG.ROTATION | PARENTFLAG.SCALE)))\n\t\t\treturn this.localTransform;\n\n\t\tlet parentTransform = undefined;\n\t\tif ((this.parentFlags & PARENTFLAG.POSITION) && (this.parentFlags & PARENTFLAG.ROTATION) && (this.parentFlags & PARENTFLAG.SCALE)) {\n\t\t\tparentTransform = this._parentTransform || new Mat4();\n\t\t}\n\t\telse {\n\t\t\tparentTransform = new Mat4();\n\t\t\tif (this.parentFlags & PARENTFLAG.POSITION)\n\t\t\t\tparentTransform.multiply(this.parentNode.positionMatrix);\n\t\t\tif (this.parentFlags & PARENTFLAG.ROTATION)\n\t\t\t\tparentTransform.multiply(this.parentNode.rotationMatrix);\n\t\t\tif (this.parentFlags & PARENTFLAG.SCALE)\n\t\t\t\tparentTransform.multiply(this.parentNode.scaleMatrix);\n\t\t}\n\t\treturn parentTransform.multiply(this.localTransform);\n\t}\n\n\t/**\n\t * @param [parentTransform] {Mat4} - The parent's final transformation matrix\n\t */\n\tupdate(parentTransform) {\n\t\tthis._inheritExternalChanges();\n\n\t\tthis._parentTransform = parentTransform\n\t\tlet finalTransform = this.worldTransform;\n\n\t\tif (this !== _rootNode) {\n\t\t\tif (!this.layer) {\n\t\t\t\t// This node's layer no longer exists, so remove this node from the tree.\n\t\t\t\treturn this.destruct();\n\t\t\t}\n\n\t\t\tthis._lastOrigin = this.layer.origin = finalTransform.toPosition();\n\t\t\tthis._lastAngles = this.layer.angles = finalTransform.toEuler(\"XYZ\");\n\t\t\tthis._lastScale = this.layer.scale = finalTransform.toScale();\n\t\t\tif (this.parentFlags & PARENTFLAG.VISIBILITY)\n\t\t\t\tthis.layer.visible = this.parentNode.layer.visible;\n\t\t}\n\n\t\t// update our children\n\t\tfor (const child of this.children) {\n\t\t\tchild.update(finalTransform);\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether any external source(s) altered properties of the layer since our last update, and updates the node state accordingly.\n\t */\n\t_inheritExternalChanges() {\n\t\tif (this !== _rootNode) {\n\t\t\tlet parentLayer = this.parentNode.layer;\n\t\t\tif (this._lastOrigin !== undefined && !OMGVector.equal(this.layer.origin, this._lastOrigin))\n\t\t\t\tthis.position = this.layer.origin.subtract(parentLayer.origin).divide(parentLayer.scale);\n\t\t\tif (this._lastAngles !== undefined && !OMGVector.equal(this.layer.angles, this._lastAngles))\n\t\t\t\tthis.rotation = this.layer.angles.subtract(parentLayer.angles);\n\t\t\tif (this._lastScale !== undefined && !OMGVector.equal(this.layer.scale, this._lastScale))\n\t\t\t\tthis.scale = this.layer.scale.divide(parentLayer.scale);\n\t\t}\n\t}\n\n\t/** \n\t * Sets the parent of this node.\n\t * @param parentNode {LayerTreeNode} - This node's new parent node.\n\t */\n\tsetParent(parentNode) {\n\t\tif (parentNode === _rootNode && this.children.length === 0)\n\t\t\tthis.destruct();\n\t\telse if (parentNode !== this.parentNode) {\n\t\t\tthis.parentNode.removeChild(this);\n\t\t\tparentNode.addChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Detaches this node from its current parent node.\n\t */\n\tunParent() {\n\t\tthis.parentNode.removeChild(this, false);\n\t}\n\n\taddChild(childNode) {\n\t\tif (childNode instanceof LayerTreeNode)\n\t\tchildNode.parentNode = this;\n\t\tthis.children.push(childNode);\n\t}\n\n\t/** \n\t * Detaches the given child node from this node, and attaches it to this node's parent. \n\t */\n\tremoveChild(childNode, attachtoParent = true) {\n\t\tchildIndex = this.children.indexOf(childNode);\n\t\tif (childIndex !== -1) {\n\t\t\tif (attachtoParent)\n\t\t\t\tchildNode.setParent(this.parentNode);\n\t\t\telse\n\t\t\t\tchildNode.setParent(_rootNode);\n\t\t\tthis.children.splice(childIndex, 1);\n\t\t}\n\t}\n\tremoveChildren() { for(const child of this.children) this.removeChild(child); }\n}\n_rootNode = new LayerTreeNode({layerID: -1, parentFlags: 0});\n\n/**\n * Returns the node for a given layer if it exists, or undefined if no node exists yet.\n * @return {LayerTreeNode}\n */\nfunction getNode(layer) {\n\treturn _treeDirectory[thisScene.getLayerIndex(layer)];\n}\n\nclass LayerParenting {\n\tstatic update(){\n\t\t_rootNode.update();\n\t}\n\n\t/**\n\t * Attaches a child layer to a parent layer, causing it to move and rotate along with the parent.\n\t * @param targetLayer {ILayer} - The child layer.\n\t * @param parentLayer {ILayer} - The parent layer.\n\t * @param [parentFlags] {PARENTFLAG} - An optional set of flags enabling or disabling parenting of various layer attributes.\n\t */\n\tstatic setParent(targetLayer, parentLayer, parentFlags = PARENTFLAG.ALL) {\n\t\tif (!targetLayer)\n\t\t\treturn null;\n\t\tif (!parentLayer) {\n\t\t\tunParent(targetLayer);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet targetNode = getNode(targetLayer);\n\t\tlet parentNode = getNode(parentLayer);\n\t\tif (parentNode === undefined)\n\t\t\tparentNode = new LayerTreeNode({\n\t\t\t\tlayerID: thisScene.getLayerIndex(parentLayer),\n\t\t\t\tposition: parentLayer.origin,\n\t\t\t\trotation: parentLayer.angles,\n\t\t\t\tscale: parentLayer.scale\n\t\t\t\t})\n\t\tif (targetNode === undefined) {\n\t\t\tnew LayerTreeNode({\n\t\t\t\tlayerID: thisScene.getLayerIndex(targetLayer), \n\t\t\t\tparentNode: parentNode, \n\t\t\t\tparentFlags: parentFlags, \n\t\t\t\tposition: targetLayer.origin.subtract(parentLayer.origin).divide(parentLayer.scale),\n\t\t\t\trotation: targetLayer.angles.subtract(parentLayer.angles),\n\t\t\t\tscale: targetLayer.scale.divide(parentLayer.scale)\n\t\t\t\t})\n\t\t}\n\t\telse if (targetNode.parentNode === parentNode) {\n\t\t\ttargetNode.parentFlags = parentFlags;\n\t\t\treturn parentLayer;\n\t\t}\n\t\telse {\n\t\t\ttargetNode.setParent(parentNode)\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns the node for a given layer if it exists, or undefined if no node exists yet.\n\t * @return {LayerTreeNode}\n\t */\n\tstatic getNode(layer) { return getNode(layer); }\n\n\t/** Detaches the given layer from its parent. Does not detach any children from the given layer. */\n\tstatic unParent(childLayer) {\n\t\tlet node = getNode(childLayer)\n\t\tif (node)\n\t\t\tnode.unParent();\n\t}\n}\nshared.LayerParenting = LayerParenting;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 12,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Interpolators (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/** @type {Interpolator[]} */\nlet activeInterps = [];\n\n\nexport function update() {\n\tactiveInterps.forEach((interp, index, array) => {\n\t\tinterp.update(engine.frametime + (shared.timeNudge || 0));\n\t});\n\tshared.timeNudge = 0;\n}\n\n\n\n\n/** Modifies an object property over a period of time */\nclass Interpolator {\n/** \n * @typedef {Object} InterpolatorParams\n * @property targetObject {object} - The object whose property value will be modified\n * @property propertyName {String} - The name of the property key to be modified\n * @property duration {Number} - How long it will take to reach the final value.\n * @property startValue {object} - An optional starting value. If not set, will use the properties existing value.\n * @property startOffset {object} - An optional offset to the starting value.\n * @property endValue {object} - The value the target variable will reach at the end of the duration. If not set, will use the properties existing value.\n * @property endOffset {object} - An optional offset to the end value.\n */\n\t/** \n\t * @param {InterpolatorParams} params - Object which allows parameters to be set by name. \n\t */\n\tconstructor(params) {\n\t\tthis.targetObject = params.targetObject;\n\t\tthis.propertyName = params.propertyName || \"origin\";\n\t\tthis.duration = params.duration || 1.0;\n\t\tthis.elapsedTime = 0;\n\t\tactiveInterps.push(this);\n\t\t\n\t\tif (params.startValue !== undefined)\n\t\t\tthis.startValue = Helpers.add(params.startValue, params.startOffset);\n\t\telse\n\t\t\tthis.startValue = Helpers.add(this.targetValue, params.startOffset);\n\t\tthis.targetValue = this.startValue;\n\t\t\n\t\tif (params.endValue !== undefined)\n\t\t\tthis.endValue = Helpers.add(params.endValue, params.endOffset);\n\t\telse\n\t\t\tthis.endValue = Helpers.add(this.targetValue, params.endOffset);\n\t}\n\n\tget targetValue() {return this.targetObject[this.propertyName]}\n\tset targetValue(newValue) {return this.targetObject[this.propertyName] = newValue}\n\n\tupdate(dt) {\n\t\tthis.elapsedTime += dt;\n\t\tif (this.elapsedTime > this.duration) {\n\t\t\tthis.finish();\n\t\t\tthis.destroy();\n\t\t}\n\t\telse\n\t\t\tthis.interpolate();\n\t}\n\n\tinterpolate() {\n\t\t// Perform interpolation here\n\t}\n\n\t/** Performs any final adjustments before this interpolator expires. */ \n\tfinish() {\n\t\tthis.targetValue = this.endValue;\n\t}\n\n\tdestroy() {\n\t\tactiveInterps.splice(activeInterps.indexOf(this), 1);\n\t}\n}\n\n\n/** Transitions from the start to end value at a constant rate. */\nclass LinearInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, percentage);\n\t}\n}\nshared.LinearInterp = LinearInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseOutInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, percentage * (2 - percentage));\n\t}\n}\nshared.EaseOutInterp = EaseOutInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseOutStrongInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, Math.pow(percentage-1, 3) + 1);\n\t}\n}\nshared.EaseOutStrongInterp = EaseOutStrongInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseInInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, Math.pow(percentage, 2));\n\t}\n}\nshared.EaseInInterp = EaseInInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first, quickly in the middle, then slow again at the end. */\nclass EaseInOutInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet x = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, x * x * (3 - 2 * x));\n\t}\n}\nshared.EaseInOutInterp = EaseInOutInterp;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 13,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Audio Manager (script)",
			"origin" : "1920.00000 1080.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n// const ScenePhase = shared.ScenePhase || function() {return shared.ScenePhase};\n// const SceneManager = shared.SceneManager || function() {return shared.SceneManager};\n\n// These values aren't defined yet, but assigning them here gives us intellisense.\n// We assign the actual class pointers in init().\nlet ScenePhase = shared.ScenePhase; \nlet SceneManager = shared.SceneManager;\n\nlet _a_TitleMusicOlder = engine.registerAsset(\"sounds/Deniz Akbulut - CrossCode Original Soundtrack EX - 11 Title (Techdemo++, 2013).mp3\")\nlet _a_TitleMusicOld = engine.registerAsset(\"sounds/menu.ogg\");\nlet _a_TitleMusic = engine.registerAsset(\"sounds/muTitle.ogg\");\nlet _a_TitleAmbient = engine.registerAsset(\"sounds/title-ambient.ogg\");\nlet _music = undefined;\nlet _ambient_volume = undefined;\n\nconst _musicRepeatDelayOlder = 64.0;\nconst _musicRepeatDelayOld = 37.0;\nconst _musicRepeatDelay = 36.25;\nconst _fadeDuration = 1.0;\nlet _currentTime = new Date().getTime();\n\n/** @type MusicLayer[] */\nlet _activeMusic = [];\n/** @type AmbienceLayer[] */\nlet _activeAmbience = [];\n/** @type SoundLayer[] */\nlet _activeSounds = [];\n\n\n\nexport function init(value) {\n\tScenePhase = shared.ScenePhase;\n\tSceneManager = shared.SceneManager;\n}\n\n\nexport function update(value) {\n\tAudioManager.update();\n}\n\n\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.music != undefined && userProperties.music != _music) {\n\t\t_music = userProperties.music;\n\t\tif (SceneManager.phase === ScenePhase.MAIN || SceneManager.phase === ScenePhase.MAIN.INTRO) {\n\t\t\tAudioManager.stopMusic();\n\t\t\tAudioManager.startMusic(_music);\n\t\t}\n\t}\n\tif (userProperties.ambient_volume != undefined && userProperties.ambient_volume != _ambient_volume) {\n\t\t_ambient_volume = userProperties.ambient_volume;\n\t}\n}\n\n\n/** Can start and stop sounds and looping music dynamically. */\nclass AudioManager {\n\tstatic update() {\n\t\t_currentTime = new Date().getTime();\n\n\t\t// Helpers.debugText(\"Sounds\", `Active Sounds? ${AudioManager.isSoundPlaying()}`);\n\t\t// Helpers.debugText(\"Music\", `Active Music? ${AudioManager.isMusicPlaying()}`);\n\t\t// Helpers.debugText(\"Ambience\", `Active Ambience? ${AudioManager.isAmbiencePlaying()}`);\n\n\t\t// Update active sounds\n\t\t_activeSounds.forEach(\n\t\t\tfunction(soundLayer, index, array) {\n\t\t\t\tsoundLayer.update();\n\t\t\t\tif (soundLayer.isDone) {\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\n\t\t// Update active music\n\t\t_activeMusic.forEach(\n\t\t\tfunction(musicLayer, index, array) {\n\t\t\t\tmusicLayer.update();\n\t\t\t\tif (musicLayer.isDone) {\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Update active music\n\t\t_activeAmbience.forEach(\n\t\t\tfunction(ambientLayer, index, array) {\n\t\t\t\tambientLayer.update();\n\t\t\t\tif (ambientLayer.isDone) {\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tstatic isSoundPlaying() {\n\t\treturn _activeSounds.some(soundLayer => soundLayer.isPlaying);\n\t}\n\n\tstatic isMusicPlaying() {\n\t\treturn _activeMusic.some(musicLayer => musicLayer.isPlaying);\n\t}\n\n\tstatic isAmbiencePlaying() {\n\t\treturn _activeAmbience.some(ambientLayer => ambientLayer.isPlaying);\n\t}\n\n\n\t/** Starts fading out all active music */\n\tstatic stopMusic() {\n\t\tfor (const musicLayer of _activeMusic)\n\t\t\tmusicLayer.startFade();\n\t}\n\n\tstatic stopAmbience() {\n\t\tfor (const ambienceLayer of _activeAmbience)\n\t\t\tambienceLayer.startFade();\n\t}\n\n\t/** Begins looping the given music track. */\n\tstatic startMusic(music = _music) {\n\t\tlet newMusic = undefined;\n\n\t\tswitch (music) {\n\t\tcase \"Old\":\n\t\t\tnewMusic = new MusicLayer(_a_TitleMusicOld, 0.5, _musicRepeatDelayOld);\n\t\t\tbreak;\n\t\tcase \"Older\":\n\t\t\tnewMusic = new MusicLayer(_a_TitleMusicOlder, 0.5, _musicRepeatDelayOlder);\n\t\t\tbreak;\n\t\tcase \"New\":\n\t\tdefault:\n\t\t\tnewMusic = new MusicLayer(_a_TitleMusic, 0.5, _musicRepeatDelay);\n\t\t\tbreak;\n\t\tcase \"None\":\n\t\t\tbreak;\n\t\t}\n\n\t\treturn newMusic;\n\t}\n\n\t/** Begins looping the ambience track. */\n\tstatic startAmbience() {\n\t\treturn new AmbientLayer(_a_TitleAmbient, _ambient_volume * 0.01, _musicRepeatDelay);\n\t}\n\n\t/** Plays a single sound\n\t * @returns {SoundLayer} The created sound layer\n\t */\n\tstatic playSound(asset, volume = 0.5) {\n\t\treturn new SoundLayer(asset, volume);\n\t}\n}\nshared.AudioManager = AudioManager;\n\n\n\nclass AudioLayer {\n\tconstructor(asset, volume = 0.5) {\n\t\tthis.asset = asset;\n\t\tlet layerSettings = new Object();\n\t\tlayerSettings.name = asset;\n\t\tlayerSettings.sound = asset;\n\t\tlayerSettings.volume = Math.max(volume, 0.001); // Give it some volume or the layer might not be created\n\t\tlayerSettings.startsilent = true;\n\t\tthis._layer = thisScene.createLayer(layerSettings);\n\t\tthis.register();\n\t}\n\n\tget volume() {return this._layer.volume}\n\tset volume(val) {return this._layer.volume = val}\n\tpause() {this._layer.pause()}\n\tstop() {this._layer.stop()}\n\tplay() {this._layer.play()}\n\tget isPlaying() {return this._layer.isPlaying()}\n\n\tregister() {_activeSounds.push(this);}\n\n\tupdate() {}\n\n\tdestroy() {\n\t\tthis.isDone = true;\n\t\tthis.stop();\n\t\tthisScene.destroyLayer(this._layer);\n\t}\n}\n\n\n/** Plays the given sound asset once, then destroys itself. */\nclass SoundLayer extends AudioLayer{\n\tconstructor(asset, volume = 0.5) {\n\t\tsuper(asset, volume);\n\t\tthis._layer.playbackmode = \"single\";\n\t\tthis.hasPlayed = false;\n\t}\n\n\tupdate() {\n\t\t// Delayed start to prevent audio hiccups\n\t\tif (!this.isPlaying) {\n\t\t\tif (!this.hasPlayed) {\n\t\t\t\tthis._layer.play();\n\t\t\t\tthis.hasPlayed = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n/** Audio layer that crossfade loops itself after the specified repeat delay */\nclass MusicLayer extends AudioLayer{\n\tconstructor(asset, volume = 0.5, repeatDelay = 9999){\n\t\tsuper(asset, volume);\n\t\tthis.unfadedVolume = volume;\n\t\tthis._layer.playbackmode = \"single\";\n\t\t/** How many seconds to play before the track loops */\n\t\tthis.repeatDelay = repeatDelay;\n\t\t/** The track will fade out for this many seconds whenever it loops */\n\t\tthis.fadeDuration = _fadeDuration;\n\t}\n\t\n\tset volume(val) {this.unfadedVolume = val}\n\tget volume() {return this.unfadedVolume}\n\tget isPlaying() {return (this.startTime && !this.bFadingOut)}\n\n\tregister() { _activeMusic.push(this); }\n\n\tupdate() {\n\t\t// Fade out then kill layer\n\t\tif (this.bFadingOut) {\n\t\t\tif (_currentTime > this.fadeEndTime) {\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet fadeLerp = (_currentTime - this.fadeStartTime) / (this.fadeEndTime - this.fadeStartTime);\n\t\t\t\tthis._layer.volume = Helpers.lerp(this.unfadedVolume, 0, fadeLerp);\n\t\t\t}\n\t\t}\n\t\t// Delayed start to prevent audio hiccups\n\t\telse if (!this._layer.isPlaying() && this.startTime === undefined) {\n\t\t\tthis._layer.play();\n\t\t\tthis.startTime = _currentTime;\n\t\t\tthis.endTime = this.startTime + this.repeatDelay * 1000;\n\t\t}\n\t\telse {\n\t\t\t// Update volume\n\t\t\tthis._layer.volume = this.unfadedVolume;\n\n\t\t\t// Start new audio\n\t\t\tif (_currentTime > this.endTime) {\n\t\t\t\tthis.loop();\n\t\t\t}\n\t\t}\n\t}\n\n\tstartFade() {\n\t\tif (!this.bFadingOut) {\n\t\t\tthis.bFadingOut = true;\n\t\t\tthis.fadeStartTime = _currentTime;\n\t\t\tthis.fadeEndTime = _currentTime + this.fadeDuration * 1000;\n\t\t}\n\t}\n\n\tloop() {\n\t\tthis.startFade();\n\t\tlet newLayer = new MusicLayer(this.asset);\n\t\tnewLayer.repeatDelay = this.repeatDelay;\n\t\tnewLayer.volume = this.unfadedVolume;\n\t}\n}\n\nclass AmbientLayer extends MusicLayer {\n\tconstructor(asset, volume = 0.5, repeatDelay = 9999){ super(asset, volume, repeatDelay); }\n\tregister() { _activeAmbience.push(this); }\n\n\tupdate() {\n\t\tsuper.update();\n\t\tthis.volume = Math.max(_ambient_volume * 0.01, 0.001);\n\t}\n\n\tloop() {\n\t\tthis.startFade();\n\t\tlet newLayer = new AmbientLayer(this.asset);\n\t\tnewLayer.repeatDelay = this.repeatDelay;\n\t\tnewLayer.volume = this.unfadedVolume;\n\t}\n}",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 14,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Scene Manager (script)",
			"origin" : "1920.00000 1080.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "100.00000 100.00000 1.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst OMGHelpers = shared.OMGHelpers;\nconst AudioManager = shared.AudioManager;\nconst LinearInterp = shared.LinearInterp;\nconst EaseOutInterp = shared.EaseOutInterp;\nconst EaseOutStrongInterp = shared.EaseOutStrongInterp;\nconst EaseInInterp = shared.EaseInInterp;\nconst EaseInOutInterp = shared.EaseInOutInterp;\nconst LayerParenting = shared.LayerParenting;\n\nlet show_developer_splash = undefined;\nlet show_intro = undefined;\nshared.timeNudge = 0;\n\n// \"Private variables\"\nlet activePhase = undefined;\nlet phaseTime = 0.0;\nlet phaseProgress = 0.0;\n\n\nconst ScenePhase = {\n\tSPLASH : {\n\t\tname : \"splash\",\n\t\tlength : 7.0,\n\t\ttimeLine : [\n\t\t\t{\n\t\t\t\ttime : 0,\n\t\t\t\texecute() {\n\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe_1\"),\n\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\tstartValue: 0,\n\t\t\t\t\t\tendValue: 1,\n\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t});\n\t\t\t\t\t// new LinearInterp({\n\t\t\t\t\t// \ttargetObject: thisScene.getLayer(\"ConcernedApe_2\"),\n\t\t\t\t\t// \tpropertyName: \"alpha\",\n\t\t\t\t\t// \tstartValue: 0,\n\t\t\t\t\t// \tendValue: 1,\n\t\t\t\t\t// \tduration: 0.5\n\t\t\t\t\t// });\n\t\t\t\t\t// new LinearInterp({\n\t\t\t\t\t// \ttargetObject: thisScene.getLayer(\"ConcernedApe_3\"),\n\t\t\t\t\t// \tpropertyName: \"alpha\",\n\t\t\t\t\t// \tstartValue: 0,\n\t\t\t\t\t// \tendValue: 1,\n\t\t\t\t\t// \tduration: 0.5\n\t\t\t\t\t// });\n\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe_4\"),\n\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\tstartValue: 0,\n\t\t\t\t\t\tendValue: 1,\n\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttime: 5,\n\t\t\t\texecute() {\n\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe_1\"),\n\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\tstartValue: 1,\n\t\t\t\t\t\tendValue: 0,\n\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t});\n\t\t\t\t\t// new LinearInterp({\n\t\t\t\t\t// \ttargetObject: thisScene.getLayer(\"ConcernedApe_2\"),\n\t\t\t\t\t// \tpropertyName: \"alpha\",\n\t\t\t\t\t// \tstartValue: 1,\n\t\t\t\t\t// \tendValue: 0,\n\t\t\t\t\t// \tduration: 0.5\n\t\t\t\t\t// });\n\t\t\t\t\t// new LinearInterp({\n\t\t\t\t\t// \ttargetObject: thisScene.getLayer(\"ConcernedApe_3\"),\n\t\t\t\t\t// \tpropertyName: \"alpha\",\n\t\t\t\t\t// \tstartValue: 1,\n\t\t\t\t\t// \tendValue: 0,\n\t\t\t\t\t// \tduration: 0.5\n\t\t\t\t\t// });\n\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe_4\"),\n\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\tstartValue: 1,\n\t\t\t\t\t\tendValue: 0,\n\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tupdate : function() {\n\t\t\tlet thisPhase = ScenePhase.SPLASH;\n\t\t\twhile (thisPhase.nextEvent < thisPhase.timeLine.length && phaseTime > thisPhase.timeLine[thisPhase.nextEvent].time) {\n\t\t\t\tthisPhase.timeLine[thisPhase.nextEvent].execute();\n\t\t\t\t++thisPhase.nextEvent;\n\t\t\t}\n\t\t},\n\t\tinit : function() {\n\t\t\tAudioManager.stopMusic();\n\t\t\tAudioManager.stopAmbience();\n\t\t\t// AudioManager.playSound(a_splashSound, 1.0);\n\t\t\tScenePhase.SPLASH.nextEvent = 0;\n\t\t\t// thisScene.getLayer(\"ConcernedApe_1\").alpha = 0;\n\t\t\t// thisScene.getLayer(\"ConcernedApe_2\").alpha = 0;\n\t\t\t// thisScene.getLayer(\"ConcernedApe_3\").alpha = 0;\n\t\t\t// thisScene.getLayer(\"ConcernedApe_4\").alpha = 0;\n\t\t\t// thisScene.getLayer(\"Splash whiteBG\").getEffect(0).getMaterial(0).multiply = 0;\n\t\t\t// thisScene.getLayer(\"html5-logo\").getEffect(0).getMaterial(0).alpha = 0;\n\t\t\t// thisScene.getLayer(\"html5-logo\").origin = new Vec3(1920, 1663.875, 0);\n\t\t\t// thisScene.getLayer(\"tech-intro-bg\").getEffect(0).getMaterial(0).alpha = 0;\n\t\t\t// thisScene.getLayer(\"tech-intro-bg\").origin = new Vec3(1920, 648, 0);\n\t\t\t// thisScene.getLayer(\"tech-intro-bg\").scale = new Vec3(6.761, 13.522, 0);\n\t\t\t// thisScene.getLayer(\"impact-logo\").getEffect(0).getMaterial(0).alpha = 0;\n\t\t\t// thisScene.getLayer(\"impact-logo\").origin = new Vec3(1920, 543.375, 0);\n\t\t\t// thisScene.getLayer(\"Splash blackBG\").getEffect(0).getMaterial(0).multiply = 0;\n\t\t},\n\t\tend : function() {\n\t\t},\n\t\texit : function() {\n\t\t\tnew LinearInterp({\n\t\t\t\ttargetObject: thisScene.getLayer(\"Splash White Fade\"),\n\t\t\t\tpropertyName: \"alpha\", \n\t\t\t\tstartValue: 1,\n\t\t\t\tendValue: 0,\n\t\t\t\tduration: 2\n\t\t\t});\n\t\t},\n\t\tget nextPhase() {return (show_intro ? ScenePhase.MAIN.INTRO : ScenePhase.MAIN)}\n\t},\n\n\n\n\tMAIN : {\n\t\tINTRO : {\n\t\t\tname : \"main.intro\",\n\t\t\tlength : 15.85,\n\t\t\ttimeLine : [\n\t\t\t\t{\n\t\t\t\t\ttime : 0,\n\t\t\t\t\texecute() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\t\t\tupdate : function() {\n\t\t\t\tlet thisPhase = ScenePhase.MAIN.INTRO;\n\t\t\t\twhile (thisPhase.nextEvent < thisPhase.timeLine.length && phaseTime > thisPhase.timeLine[thisPhase.nextEvent].time) {\n\t\t\t\t\tthisPhase.timeLine[thisPhase.nextEvent].execute();\n\t\t\t\t\t++thisPhase.nextEvent;\n\t\t\t\t}\n\t\t\t},\n\t\t\tinit : function() {\n\t\t\t\t// if (!AudioManager.isMusicPlaying())\n\t\t\t\t// \tAudioManager.startMusic();\n\t\t\t\t// if (!AudioManager.isAmbiencePlaying())\n\t\t\t\t// \tAudioManager.startAmbience();\n\t\t\t\tScenePhase.MAIN.INTRO.nextEvent = 0;\n\t\t\t},\n\t\t\tend : function() {},\n\t\t\texit : function() {},\n\t\t\tget nextPhase() {return ScenePhase.MAIN}\n\t\t},\n\n\n\n\t\tname : \"main\",\n\t\tget nextPhase() {return null},\n\t\tlength : 0.0,\n\t\tupdate : function() {\n\n\t\t},\n\t\tinit : function() {\n\t\t\tif (!AudioManager.isMusicPlaying())\n\t\t\t\tAudioManager.startMusic();\n\t\t\tif (!AudioManager.isAmbiencePlaying())\n\t\t\t\tAudioManager.startAmbience();\n\t\t\tScenePhase.MAIN.nextEvent = 0;\n\t\t},\n\t\tend : function() {},\n\t\texit : function() {}\n\t}\n}\nshared.ScenePhase = ScenePhase;\n\nclass SceneManager {\n\tstatic update() {\n\t\t// \n\t\tshared.timeNudge = 0;\n\t\t\n\t\tif (activePhase) {\n\t\t\t// Advance phase\n\t\t\tphaseTime += engine.frametime;\n\t\t\tif (phaseTime > activePhase.length && activePhase.nextPhase) {\n\t\t\t\tSceneManager.advancePhase();\n\t\t\t}\n\t\t\tif (activePhase.length !== 0)\n\t\t\t\tshared.phaseProgress = phaseTime / activePhase.length;\n\t\t\telse \n\t\t\t\tshared.phaseProgress = 0.0;\n\n\t\t\t// Update active phase\n\t\t\tif (typeof(activePhase.update) === \"function\")\n\t\t\t\tactivePhase.update();\n\t\t}\n\t}\n\t\n\tstatic get phase() {return activePhase}\n\n\tstatic get phaseTime() {return phaseTime}\n\n\tstatic advancePhase() {\n\t\tif (typeof(activePhase.end) === \"function\")\n\t\t\tactivePhase.end();\n\t\tSceneManager.setPhase(activePhase.nextPhase);\n\t}\n\n/** Initialize the currently active phase */\n\tstatic setPhase(newPhase, bInit = true) {\n\t\tif (activePhase && typeof(activePhase.exit) === \"function\")\n\t\t\tactivePhase.exit();\n\t\tactivePhase = newPhase;\n\t\tphaseTime = 0;\n\t\tif (bInit && typeof(activePhase.init) === \"function\")\n\t\t\tactivePhase.init();\n\t}\n}\nshared.SceneManager = SceneManager;\n\n\n\n/** Initialize in update instead of init, since we want to load user settings before we initialize */\nlet bFirstUpdate = true;\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function update(value) {\n\tif (bFirstUpdate) {\n\t\tbFirstUpdate = false;\n\n\t\t// Set the initial phase in update(), as init() runs before we get user properties\n\t\tif (show_developer_splash)\n\t\t\tSceneManager.setPhase(ScenePhase.SPLASH);\n\t\telse if (show_intro)\n\t\t\tSceneManager.setPhase(ScenePhase.MAIN.INTRO);\n\t\telse\n\t\t\tSceneManager.setPhase(ScenePhase.MAIN);\n\t}\n\telse\n\t\tSceneManager.update();\n\treturn value;\n}\n\n\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.show_intro !== undefined && userProperties.show_intro !== show_intro) {\n\t\tshow_intro = userProperties.show_intro;\n\t\t// Jump to intro when enabled\n\t\tif (!bFirstUpdate) {\n\t\t\tif (show_intro && SceneManager.phase === ScenePhase.MAIN)\n\t\t\t\tSceneManager.setPhase(ScenePhase.MAIN.INTRO);\n\t\t\t// else if (SceneManager.phase === ScenePhase.MAIN.INTRO)\n\t\t\t// \tSceneManager.advancePhase();\n\t\t}\n\t}\n\tif (userProperties.show_developer_splash !== undefined && userProperties.show_developer_splash !== show_developer_splash) {\n\t\tshow_developer_splash = userProperties.show_developer_splash;\n\t\t// Jump to splash screen when enabled\n\t\tif (!bFirstUpdate) {\n\t\t\tif (show_developer_splash && SceneManager.phase === ScenePhase.MAIN)\n\t\t\t\tSceneManager.setPhase(ScenePhase.SPLASH);\n\t\t\t// else if (SceneManager.phase === ScenePhase.SPLASH)\n\t\t\t// \tSceneManager.advancePhase();\n\t\t}\n\t}\n}\n\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorClick(event) {\n\tswitch (activePhase) {\n\tcase ScenePhase.SPLASH:\n\t\t// shared.timeNudge = ScenePhase.SPLASH.length - phaseTime;\n\t\t// phaseTime = ScenePhase.SPLASH.length;\n\t\tbreak;\n\tcase ScenePhase.MAIN.INTRO:\n\t\t// if (phaseTime < 0.6) {\n\t\t// \tAudioManager.playSound(\"logo-instant-bling-quick.ogg\")\n\t\t// \tshared.timeNudge = 0.6 - phaseTime;\n\t\t// \tphaseTime = 0.6;\n\t\t// }\n\t\tbreak;\n\t}\n}\n",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 15,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Shared logic",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "// 'use strict';\n\n// shared.viewportY = 0;\n// let viewportDY = 0.01;\n\n// export function init() {\n// }\n\n\n// export function update() {\n// \tshared.viewportY += viewportDY;\n// \tif (viewportDY > 0.0)\n// \t\tviewportDY += 3.0/500.0;\n// \tif (shared.viewportY > 1000.0) {\n// \t\tif (viewportDY != 0.0) {\n// \t\t\t// stuff\n// \t\t}\n// \t\tviewportDY = 0.0;\n// \t}\n\t\t\n// }",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 16,
			"image" : "models/Sky.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Sky",
			"origin" : 
			{
				"script" : "// 'use strict';\n\n// /**\n//  * @param {Vec3} value - for property 'origin'\n//  * @return {Vec3} - update current property value\n//  */\n// export function update(value) {\n// \treturn new Vec3(960, Math.round(900 - shared.viewportY * 0.66 + 270), 0);\n// }\n",
				"value" : "960.00000 1170.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1920.00000 6.13630 1.00000",
			"size" : "1.00000 264.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 35,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Splash White Fade",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "1920.00000 1080.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 38,
			"image" : "models/ConcernedApe_1.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "ConcernedApe_1",
			"origin" : "830.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "3.00000 3.00000 3.00000",
			"size" : "85.00000 69.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 42,
			"image" : "models/ConcernedApe_4.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "ConcernedApe_4",
			"origin" : "1130.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "3.00000 3.00000 1.00000",
			"size" : "111.00000 57.00000",
			"solid" : true,
			"visible" : true
		}
	],
	"version" : 1
}