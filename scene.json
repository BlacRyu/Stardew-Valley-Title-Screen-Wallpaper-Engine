{
	"camera" : 
	{
		"center" : "0.00000 0.00000 0.00000",
		"eye" : "0.00000 0.00000 1.00000",
		"up" : "0.00000 1.00000 0.00000"
	},
	"general" : 
	{
		"ambientcolor" : "0.30000 0.30000 0.30000",
		"bloom" : false,
		"bloomhdrfeather" : 0.050000001,
		"bloomhdriterations" : 8,
		"bloomhdrscatter" : 1.6,
		"bloomhdrstrength" : 1.0,
		"bloomhdrthreshold" : 1.0,
		"bloomstrength" : 0.0,
		"bloomthreshold" : 1.0,
		"camerafade" : true,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.5,
		"cameraparallaxdelay" : 0.1,
		"cameraparallaxmouseinfluence" : 1.0,
		"camerapreview" : true,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.25098 0.53333 0.97255",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 50.0,
		"hdr" : true,
		"nearz" : 0.0099999998,
		"orthogonalprojection" : 
		{
			"height" : 1080,
			"width" : 1920
		},
		"skylightcolor" : "0.30000 0.30000 0.30000",
		"zoom" : 1.0
	},
	"objects" : 
	[
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 7,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGHelpers (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addColor({\n\t\tname: 'debugText_FlashColor',\n\t\tlabel: 'Debug Flash Color',\n\t\tvalue: new Vec3(0.5, 1.0, 1.0)\n\t})\n\t.finish();\n\nlet bEnableDebugText = true;\nlet debugText_Layers = [];\n// let debugText_FlashColor = new Vec3(0.5, 1.0, 1.0);\nlet debugText_Color = new Vec3(1.0, 1.0, 1.0);\nlet debugText_ShowBackground = true;\nlet debugText_BackgroundColor = new Vec3(0.1, 0.1, 0.1);\nlet debugText_Size = 5;\nlet debugText_Alpha = 0.75;\nlet debugText_FlashScale = 1.01;\n/** How many milliseconds to fade from the flash color to the normal color when the text is updated. */\nlet debugText_FlashTime = 250;\n/** How many milliseconds to display the text before starting to fade out. */\nlet debugText_DisplayTime = 500;\n/** How many milliseconds to fade out the debug text before removing it. */\nlet debugText_FadeTime = 1500;\n\n\nlet _canvasToScreen = 1.0;\n\n\nexport function update() {\n\tlet currentTime = new Date().getTime();\n\tlet linesDisplayed = 0;\n\t\n\tdebugText_Layers.forEach(\n\t\tfunction(textLayer, index, array) {\n\t\t\tlet displayTime = textLayer.displayTime || debugText_DisplayTime;\n\t\t\tif (currentTime > textLayer.lastUpdated + (displayTime + debugText_FadeTime)) {\n\t\t\t\ttextLayer.alpha = 0;\n\t\t\t\tthisScene.destroyLayer(textLayer);\n\t\t\t\tarray.splice(index, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (currentTime > textLayer.lastUpdated + displayTime) {\n\t\t\t\ttextLayer.color = debugText_Color;\n\t\t\t\tlet fadeLerp = (currentTime - (textLayer.lastUpdated + displayTime)) / debugText_FadeTime;\n\t\t\t\ttextLayer.alpha = OMGHelpers.lerp(debugText_Alpha, 0, fadeLerp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet flashLerp = OMGHelpers.clamp((currentTime - textLayer.lastChanged) / debugText_FlashTime);\n\t\t\t\ttextLayer.color = OMGHelpers.lerp(scriptProperties.debugText_FlashColor, debugText_Color, flashLerp);\n\t\t\t\ttextLayer.scale = new Vec3(OMGHelpers.lerp(debugText_FlashScale * _canvasToScreen, 1 * _canvasToScreen, flashLerp));\n\t\t\t\ttextLayer.alpha = debugText_Alpha;\n\t\t\t}\n\n\t\t\tif (engine.canvasSize.x !== 0) {\n\t\t\t\tlet cornerY = engine.canvasSize.y;\n\t\t\t\tlet cornerX = 0;\n\t\t\t\tlet screenAspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\t\t\t\tlet canvasAspectRatio = engine.canvasSize.x / engine.canvasSize.y;\n\t\t\t\tif (screenAspectRatio > canvasAspectRatio) {\n\t\t\t\t\tcornerY = engine.screenResolution.y * engine.canvasSize.x / engine.screenResolution.x;\n\t\t\t\t\tcornerY += (engine.canvasSize.y - cornerY) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcornerX = engine.screenResolution.x * engine.canvasSize.y / engine.screenResolution.y;\n\t\t\t\t\tcornerX = (engine.canvasSize.x - cornerX) / 2;\n\t\t\t\t}\n\t\t\t\ttextLayer.origin = new Vec3(cornerX, cornerY - linesDisplayed * (debugText_Size * 4.9 - 0.5) * _canvasToScreen, 0);\n\t\t\t}\n\t\t\telse { // 3D Scene\n\t\t\t\tlet aspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\t\t\t\tlet ct = thisScene.getCameraTransforms();\n\t\t\t\tlet forward = ct.center.subtract(ct.eye).normalize();\n\t\t\t\tlet up = ct.up;\n\t\t\t\tlet right = forward.cross(up);\n\t\t\t\tlet pos = ct.eye.add(forward).add(up.multiply(0.45)).add(right.multiply(-0.45 * aspectRatio));\n\t\t\t\tpos.y -= linesDisplayed * (debugText_Size * .002);\n\t\t\t\ttextLayer.origin = new Vec3(pos.x, pos.y, pos.z);\n\t\t\t\ttextLayer.scale = new Vec3(0.0005);\n\t\t\t}\n\t\t\ttextLayer.pointsize = debugText_Size;\n\t\t\ttextLayer.visible = bEnableDebugText;\n\t\t\tlinesDisplayed += textLayer.text.split('\\n').length;\n\t\t}\n\t);\n}\n\n\nexport function init() {\n\t_canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n}\n\n\nexport function resizeScreen() {\n\t_canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n}\n\n\n\n\nclass OMGHelpers {\n\t/** Prints all key/value pairs present on the object to the console. */\n\tstatic printObjectValues(obj){\n\t\tif (typeof(obj) !== 'object' || obj === null)\n\t\t\treturn;\n\n\t\tfor (const key of Object.keys(obj))\n\t\t\tconsole.log(key + \" - \" + obj[key]);\n\t}\n\n\t/** Attempts to add two values together. */\n\tstatic add(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 + v2;\n\t\telse if (v1.add)\n\t\t\treturn v1.add(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to subtract the second value from the first value. */\n\tstatic subtract(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 - v2;\n\t\telse if (v1.subtract)\n\t\t\treturn v1.subtract(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to multiply two values together. */\n\tstatic multiply(v1, v2) {\n\t\tif (v2 === undefined)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to divide the first value by the second value. */\n\tstatic divide(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/**\n\t * True if the two parameters are the same type and contain equal values, otherwise false\n\t * @param [epsilon] {number} The minimum difference allowed between number values before they are considered non-equal (helps avoid some floating-point issues)\n\t * @return {boolean}\n\t */\n\tstatic equal(v1, v2, epsilon = 0.0001){\n\t\tif (v1 instanceof Vec3) {\n\t\t\tif (v2 instanceof Vec3)\n\t\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v1.z) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tif (v2 instanceof Vec2)\n\t\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse switch (typeof v1) {\n\t\tcase \"number\":\n\t\t\tif (typeof v2 === \"number\")\n\t\t\t\treturn (Math.abs(v1 - v2) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (v1 === v2);\n\t\t}\n\t}\n\n\t/** Restricts a value to remain between two boundary values. \n\t * @param {number} val - The value to be restricted.\n\t * @param {number} min - The lower bound.\n\t * @param {number} max - The upper bound.\n\t*/\n\tstatic clamp(val, min = 0, max = 1) {\n\t\tif (typeof(val) === \"number\")\n\t\t\treturn Math.min(max, Math.max(min, val));\n\t\telse if (val instanceof Vec2) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (val instanceof Vec3) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\tlet z = Math.min(max.z, Math.max(min.z, val.z));\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (val instanceof Vec4) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\tlet z = Math.min(max.z, Math.max(min.z, val.z));\n\t\t\tlet w = Math.min(max.w, Math.max(min.w, val.w));\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t}\n\n\t/** Interpolate linearly from the first value to the second based on the third (0 to 1) */\n\tstatic lerp(v1, v2, percent) {\n\t\tif (typeof(v1) === \"number\")\n\t\t\treturn v1 + (v2 - v1) * percent;\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (v1 instanceof Vec3) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (v1 instanceof Vec4) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\tlet w = v1.w + (v2.w - v1.w) * percent;\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Prints a stack trace to the console. */\n\tstatic stackTrace() {\n\t\treturn console.log(new Error().stack);\n\t}\n\t\n\t/** Creates or updates a text layer in the corner of the screen. \n\t * @param {string} name - The name of the text layer to create or update.\n\t * @param {string} text - The text that the layer should display.\n\t * @param {number} displayTime - How many milliseconds the message should be displayed for.\n\t*/\n\tstatic debugText(name, text, displayTime) {\n\t\tif (bEnableDebugText && name !== undefined && text !== undefined) {\n\t\t\tlet layer = thisScene.getLayer(name.toString() + \"_debugText\");\n\t\t\tif (layer) {\n\t\t\t\tif (layer.text != text) {\n\t\t\t\t\tlayer.text = text;\n\t\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\t\tlayer.displayTime = displayTime;\n\t\t\t\t\tlayer.color = scriptProperties.debugText_FlashColor;\n\t\t\t\t\tlayer.scale = new Vec3(debugText_FlashScale * _canvasToScreen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlayer.lastUpdated = new Date().getTime();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet layerSettings = new Object();\n\t\t\t\tif (engine.canvasSize.x !== 0) {\n\t\t\t\t\tlayerSettings.origin = \"0, \" + (engine.canvasSize.y - debugText_Layers.length * (debugText_Size * 3 + 10)) + \", 0\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet ct = thisScene.getCameraTransforms();\n\t\t\t\t\tlet forward = ct.center.subtract(ct.eye).normalize();\n\t\t\t\t\tlet up = ct.up;\n\t\t\t\t\tlet right = forward.cross(up);\n\t\t\t\t\tlet pos = new Vec3(0, .5, 0);//ct.eye.add(forward);//.add(right);\n\t\t\t\t\tlayerSettings.origin = `${pos.x}, ${pos.y}, ${pos.z}`;\n\t\t\t\t}\n\t\t\t\tlayerSettings.name = name.toString() + \"_debugText\";\n\t\t\t\tlayerSettings.text = text;\n\t\t\t\tlayerSettings.pointsize = debugText_Size;\n\t\t\t\tlayerSettings.font = \"systemfont_consolas\";\n\n\t\t\t\tlayerSettings.verticalalign = \"top\";\n\t\t\t\tlayerSettings.horizontalalign = \"left\";\n\t\t\t\tlayerSettings.color = scriptProperties.debugText_FlashColor.x + \", \" + scriptProperties.debugText_FlashColor.y + \", \" + scriptProperties.debugText_FlashColor.z;\n\t\t\t\tlayerSettings.opaquebackground = debugText_ShowBackground;\n\t\t\t\tlayerSettings.backgroundcolor = debugText_BackgroundColor;\n\t\t\t\tlayerSettings.padding = 0;\n\t\t\t\tlayerSettings.alpha = debugText_Alpha;\n\t\t\t\tlayer = thisScene.createLayer(layerSettings);\n\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\tlayer.displayTime = displayTime;\n\t\t\t\tdebugText_Layers.push(layer);\n\t\t\t}\n\t\t}\n\t}\n}\n\nshared.OMGHelpers = OMGHelpers;",
				"scriptproperties" : 
				{
					"debugText_FlashColor" : "0.49804 1.00000 1.00000"
				},
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 9,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGMatrix (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n// matrix functions referenced from https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js\n\nconst deg2rad = Math.PI / 180;\nconst rad2deg = 180 / Math.PI;\n\nfunction clamp(x, min, max){ return Math.max(Math.min(x, max), min) }\n\nclass Mat4 {\n\tconstructor(b){\n\t\tif (b instanceof Mat4){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = b.elements[i].slice();\n\t\t\t}\n\t\t}\n\t\telse if (arguments.length === 16){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = new Array(4);\n\t\t\t\tfor(let j = 0; j < 4; j++){\n\t\t\t\t\tthis.elements[i][j] = arguments[i*4 + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tthis.elements = [\n\t\t\t\t[1, 0, 0, 0],\n\t\t\t\t[0, 1, 0, 0],\n\t\t\t\t[0, 0, 1, 0],\n\t\t\t\t[0, 0, 0, 1]\n\t\t\t];\n\t\t}\n\t}\n\n\n\tprintElements(){\n\t\tfor(let x = 0; x < 4; x++){\n\t\t\tlet line = \"\";\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tline += this.elements[x][y].toString() + \" \";\n\t\t\t}\n\t\t\tconsole.log(line);\n\t\t}\n\t}\n\n\n\tmultiply(right){\n\t\tlet a = this.elements;\n\t\tlet b = right.elements;\n\t\tlet r = new Mat4();\n\n\t\tfor (let x = 0; x < 4; x++){\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tr.elements[x][y] = a[x][0] * b[0][y] + a[x][1] * b[1][y] + a[x][2] * b[2][y] + a[x][3] * b[3][y];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\n\tstatic fromAxisAngle(axis, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\tlet t = 1 - cos;\n\t\tlet x = axis.x, y = axis.y, z = axis.z;\n\t\tlet tx = t*x, ty = t*y;\n\n\t\treturn new Mat4(\n\t\t\ttx * x + cos,      tx * y - sin * z,  tx * z + sin * y,  0,\n\t\t\ttx * y + sin * z,  ty * y + cos,      ty * z - sin * x,  0,\n\t\t\ttx * z - sin * y,  ty * z + sin * x,  t * z * z + cos,   0,\n\t\t\t0,                 0,                 0,                 1\n\t\t);\n\t}\n\n\n\tstatic fromPosition(pos){\n\t\treturn new Mat4(\n\t\t\t1, 0, 0, pos.x,\n\t\t\t0, 1, 0, pos.y,\n\t\t\t0, 0, 1, pos.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\t}\n\n\n\ttoPosition(){\n\t\tlet m = this.elements;\n\t\treturn new Vec3(m[0][3], m[1][3], m[2][3]);\n\t}\n\n\n\tstatic fromEuler(angles, order){\n\t\tlet r = new Mat4();\n\t\tlet e = angles.multiply(deg2rad);\n\t\tlet sx = Math.sin(e.x), sy = Math.sin(e.y), sz = Math.sin(e.z);\n\t\tlet cx = Math.cos(e.x), cy = Math.cos(e.y), cz = Math.cos(e.z);\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = -cy * sz;\n\t\t\t\tr.elements[0][2] = sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz + sx * cz * sy;\n\t\t\t\tr.elements[1][1] = cx * cz - sx * sz * sy;\n\t\t\t\tr.elements[1][2] = -sx * cy;\n\n\t\t\t\tr.elements[2][0] = sx * sz - cx * cz * sy;\n\t\t\t\tr.elements[2][1] = sx * cz + cx * sz * sy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YXZ\":\n\t\t\t\tr.elements[0][0] = cy * cz + sy * sz * sx;\n\t\t\t\tr.elements[0][1] = sy * cz * sx - cy * sz;\n\t\t\t\tr.elements[0][2] = cx * sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx;\n\n\t\t\t\tr.elements[2][0] = cy * sz * sx - sy * cz;\n\t\t\t\tr.elements[2][1] = sy * sz + cy * cz * sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZXY\":\n\t\t\t\tr.elements[0][0] = cy * cz - sy * sz * sx\n\t\t\t\tr.elements[0][1] = -cx * sz;\n\t\t\t\tr.elements[0][2] = sy * cz + cy * sz * sx;\n\n\t\t\t\tr.elements[1][0] = cy * sz + sy * cz * sx;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = sy * sz - cy * cz * sx;\n\n\t\t\t\tr.elements[2][0] = -cx * sy;\n\t\t\t\tr.elements[2][1] = sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZYX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * cz * sy - cx * sz;\n\t\t\t\tr.elements[0][2] = cx * cz * sy + sx * sz;\n\n\t\t\t\tr.elements[1][0] = cy * sz;\n\t\t\t\tr.elements[1][1] = sx * sz * sy + cx * cz;\n\t\t\t\tr.elements[1][2] = cx * sz * sy - sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy;\n\t\t\t\tr.elements[2][1] = sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YZX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * sy - cx * cy * sz;\n\t\t\t\tr.elements[0][2] = sx * cy * sz + cx * sy;\n\n\t\t\t\tr.elements[1][0] = sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy * cz;\n\t\t\t\tr.elements[2][1] = cx * sy * sz + sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy - sx * sy * sz;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// right colur.elementsn\n\t\tr.elements[0][3] = 0;\n\t\tr.elements[1][3] = 0;\n\t\tr.elements[2][3] = 0;\n\t\t\n\t\t// bottor.elements row\n\t\tr.elements[3][0] = 0;\n\t\tr.elements[3][1] = 0;\n\t\tr.elements[3][2] = 0;\n\t\tr.elements[3][3] = 1;\n\n\t\treturn r;\n\t}\n\n\n\ttoEuler(order){\n\t\tlet m = this.elements;\n\t\tlet x,y,z;\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\ty = Math.asin(clamp(m[0][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][2] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YXZ\":\n\t\t\t\tx = Math.asin(-clamp(m[1][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][2] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZXY\":\n\t\t\t\tx = Math.asin(clamp(m[2][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][1] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZYX\":\n\t\t\t\ty = Math.asin(-clamp(m[2][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YZX\":\n\t\t\t\tz = Math.asin(clamp(m[1][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[1][1]);\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"XZY\":\n\t\t\t\tz = Math.asin(-clamp(m[0][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][1] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\ty = Math.atan2(m[0][2], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tlet euler = new Vec3(x, y, z);\n\t\teuler = euler.multiply(rad2deg);\n\t\treturn euler;\n\t}\n\n\tstatic fromScale(s) {\n\t\treturn new Mat4(\n\t\t\ts.x, 0,   0,   0,\n\t\t\t0,   s.y, 0,   0,\n\t\t\t0,   0,   s.z, 0,\n\t\t\t0,   0,   0,   1\n\t\t);\n\t}\n\n\ttoScale() {\n\t\tlet m = this.elements;\n\t\treturn new Vec3(\n\t\t\tMath.sqrt(m[0][0]*m[0][0] + m[0][1]*m[0][1] + m[0][2]*m[0][2]),\n\t\t\tMath.sqrt(m[1][0]*m[1][0] + m[1][1]*m[1][1] + m[1][2]*m[1][2]),\n\t\t\tMath.sqrt(m[2][0]*m[2][0] + m[2][1]*m[2][1] + m[2][2]*m[2][2])\n\t\t);\n\t}\n};\n\nshared.Mat4 = Mat4;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 10,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGVector (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nclass OMGVector {\n\t/**\n\t * @param {Vec3} vector\n\t * @param {Number} angle\n\t * Rotates the vector in radians around the X axis\n\t */\n\tstatic rotX(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x, \n\t\t\tvector.y * cos - vector.z * sin,\n\t\t\tvector.y * sin + vector.z * cos)\n\t};\n\n\tstatic rotY(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos + vector.z * sin,\n\t\t\tvector.y, \n\t\t\t-vector.x * sin + vector.z * cos)\n\t};\n\n\tstatic rotZ(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos - vector.y * sin,\n\t\t\tvector.x * sin + vector.y * cos,\n\t\t\tvector.z)\n\t};\n\n\tstatic rotAxis(vec, angle, axis){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\t(cos + (1 - cos) * axis.x * axis.x) * vec.x +\n\t\t\t((1 - cos) * axis.x * axis.y - axis.z * sin) * vec.y +\n\t\t\t((1 - cos) * axis.x * axis.z + axis.y * sin) * vec.z,\n\n\t\t\t((1 - cos) * axis.x * axis.y + axis.z * sin) * vec.x +\n\t\t\t(cos + (1 - cos) * axis.y * axis.y) * vec.y +\n\t\t\t((1 - cos) * axis.y * axis.z - axis.x * sin) * vec.z,\n\n\t\t\t((1 - cos) * axis.x * axis.z - axis.y * sin) * vec.x +\n\t\t\t((1 - cos) * axis.y * axis.z + axis.x * sin) * vec.y +\n\t\t\t(cos + (1 - cos) * axis.z * axis.z) * vec.z\n\t\t);\n\t};\n\n\tstatic rotVec(vector, angles){\n\t\tlet r = rotX(vector, angles.x);\n\t\tr = rotY(r, angles.y);\n\t\treturn r = rotZ(r, angles.z);\n\t};\n\n\tstatic unrotVec(vector, angles){\n\t\tlet r = rotZ(vector, -angles.x);\n\t\tr = rotY(r, -angles.y);\n\t\treturn r = rotX(r, -angles.z);\n\t};\n\n\tstatic forwardY(angles){\n\t\treturn rotVec(new Vec3(0., 1., 0.), angles);\n\t};\n\n\tstatic forwardZ(angles){\n\t\treturn rotVec(new Vec3(0., 0., 1.), angles);\n\t};\n\n\tstatic forwardX(angles){\n\t\treturn rotVec(new Vec3(1., 0., 0.), angles);\n\t};\n\n\tstatic interpAngle(angle1, angle2, percent){\n\t\tlet a1 = [angle1.x % 360, angle1.y % 360, angle1.z % 360];\n\t\tlet a2 = [angle2.x % 360, angle2.y % 360, angle2.z % 360];\n\t\tlet diff = [];\n\t\tfor (let i = 0; i < 3; i++){\n\t\t\tif (a1[i] < 0)\n\t\t\t\ta1[i] += 360;\n\t\t\tif (a2[i] < 0)\n\t\t\t\ta2[i] += 360;\n\t\t\tdiff[i] = a2[i] - a1[i];\n\t\t\tif (diff[i] > 180)\n\t\t\t\tdiff[i] -= 360;\n\t\t\telse if (diff[i] < -180)\n\t\t\t\tdiff[i] += 360;\n\t\t}\n\t\treturn new Vec3(a1[0] + diff[0] * percent, a1[1] + diff[1] * percent, a1[2] + diff[2] * percent);\n\t};\n\n\tstatic interpPosition(pos1, pos2, percent){\n\t\treturn lerp(pos1, pos2, percent);\n\t}\n\n\t/**\n\t * Interpolates linearly between v1 and v2 based on percent (0 to 1).\n\t * @param {Vec3} v1 First vector\n\t * @param {Vec3} v2 Second vector\n\t * @param {Number} percent interpolation value between 0 and 1\n\t */\n\tstatic lerp(v1, v2, percent){\n\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\treturn new Vec3(x, y, z);\n\t};\n\t\n\n\tstatic magnitude(vec){\n\t\treturn Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n\t}\n\n\tstatic normalize(vec){\n\t\treturn vec.multiply(1 / OMGVector.magnitude(vec));\n\t};\n\n\t/**\n\t * True if the two vectors contain equal x, y, and z values, otherwise false\n\t * @param [epsilon] {number} The minimum difference allowed between vector values before they are considered non-equal (helps avoid some floating-point issues)\n\t * @return {boolean}\n\t */\n\tstatic equal(v1, v2, epsilon = 0.0001){\n\t\tif (epsilon)\n\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v1.z) < epsilon);\n\t\telse\n\t\t\treturn (v1.x === v2.x && v1.y === v2.y && v1.z === v1.z);\n\t}\n}\n\nshared.OMGVector = OMGVector;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 11,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "LayerParenting (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addCheckbox({\n\t\tname: 'debug',\n\t\tlabel: 'Debug',\n\t\tvalue: false\n\t})\n\t.addCheckbox({\n\t\tname: 'printToScreen',\n\t\tlabel: 'Print to Screen',\n\t\tvalue: false\n\t})\n\t.addCheckbox({\n\t\tname: 'debug_nodeCreation',\n\t\tlabel: 'Debug Node Creation',\n\t\tvalue: false\n\t})\n\t.finish();\n\n// Layer Parenting system which allows layers to inherit various properties from another layer.\n// Created by OMGparticles, 2021\n// If you find this, feel free to use it in your own project. It may have issues, but has worked \n// well enough for my personal projects.\n\nconst Helpers = shared.OMGHelpers;\nconst Mat4 = shared.Mat4;\nconst OMGVector = shared.OMGVector;\n\nexport function init() { \n\t// Create a simple dummy layer for the root node.\n\t_rootNode.layer = thisScene.createLayer({\n\t\tname: \"_LayerParenting_rootNode\",\n\t\timage : \"models/util/solidlayer.json\",\n\t\tsize : \"0 0\"\n\t\t});\n}\nexport function update() { LayerParenting.update(); }\n\n\n/**\n * Bitwise flags representing the properties of the parent layer which should be inherited.\n * @enum {number} \n */\nconst PARENTFLAG = {\n\tPOSITION   : 1 << 0,\n\tROTATION   : 1 << 1,\n\tSCALE      : 1 << 2,\n\tVISIBILITY : 1 << 3,\n\tALL        : ~0,\n\tNONE       : 0\n}\nshared.PARENTFLAG = PARENTFLAG;\n\n\n/** \n * Contains references to every non-root node, indexed by the scene layer object.\n */\nconst _treeDirectory = new Map();\n\n/** \n * Root node for the scene. Any children of this node effectively have no parent.\n * @type {LayerTreeNode}\n */\nlet _rootNode = undefined; // gets defined after LayerTreeNode's definition.\n\n/** \n * Node in the layer tree which represents a layer and its relationship to any child layers. \n */\nclass LayerTreeNode {\n/** \n * @typedef LayerTreeNodeParams {Object} \n * @property layer {ILayer} - The scene layer represented by this node.\n * @property [parentNode] {LayerTreeNode} - This node's parent.\n * @property [parentFlags] {PARENTFLAG} - An optional set of flags enabling or disabling parenting of various layer attributes.\n * @property [position] {Vec3} - The layer's translational offset from the parent.\n * @property [rotation] {Vec3} - The layer's local rotation in degrees.\n * @property [scale] {Vec3} - The layer's scale.\n */\n\t/** \n\t * @param params {LayerTreeNodeParams} - Object which enables parameters to be set by name rather than by sequence. \n\t */\n\tconstructor(params = {}){\n\t\tthis.layer = params.layer;\n\t\tthis.parentNode = params.parentNode || _rootNode;\n\t\tif (this.parentNode !== undefined) // Will be undefined when creating _rootNode\n\t\t\tthis.parentNode.addChild(this);\n\t\tif (params.parentFlags !== undefined)\n\t\t\tthis.parentFlags = params.parentFlags;\n\t\telse\n\t\t\tthis.parentFlags = PARENTFLAG.ALL;\n\t\t\n\t\t/** @type LayerTreeNode[] */\n\t\tthis.children = [];\n\t\t\n\t\tif (this.layer) {\n\t\t\tthis._lastOrigin = this.layer.origin;\n\t\t\tthis._lastAngles = this.layer.angles;\n\t\t\tthis._lastScale = this.layer.scale;\n\t\t}\n\t\tthis._position = params.position || new Vec3(0, 0, 0);\n\t\tthis._positionMatrix = new Mat4();\n\t\tthis._positionChanged = true;\n\n\t\tthis._rotation = params.rotation || new Vec3(0, 0, 0);\n\t\tthis._rotationMatrix = new Mat4();\n\t\tthis._rotationChanged = true;\n\t\t\n\t\tthis._scale = params.scale || new Vec3(1, 1, 1);\n\t\tthis._scaleMatrix = new Mat4();\n\t\tthis._scaleChanged = true;\n\n\t\tthis._localTransform = new Mat4();\n\t\tthis._localTransformChanged = true;\n\t\t\n\t\t_treeDirectory.set(this.layer, this);\n\n\t\tif (scriptProperties.debug && scriptProperties.debug_nodeCreation) {\n\t\t\tlet message = `Created new LayerTreeNode \"${this.name}\" with parent \"${this.parentNode.name}\"\\n`;\n\t\t\tmessage += `========== Node params ==========\\n`;\n\t\t\tfor (let param in params){\n\t\t\t\tmessage += `${param}: ${params[param]}\\n`;\n\t\t\t}\n\t\t\tmessage += `========== End params ===========`\n\t\t\tfor (let line of message.split('\\n'))\n\t\t\t\tconsole.log(line);\n\t\t\tif (scriptProperties.printToScreen){\n\t\t\t\tHelpers.debugText(message);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Removes this node from the tree.\n\t */\n\tdestruct() {\n\t\tremoveChildren();\n\t\tthis.parentNode.removeChild(this);\n\t\t_treeDirectory.delete(this.layer);\n\t\treturn null;\n\t}\n\n\tget name() { return this.layer.name; }\n\n\t/** @return {Vec3} The local offset from the parent's position. */\n\tget position() { return this._position; }\n\tset position(newPos) {\n\t\tif (newPos instanceof Vec3) {\n\t\t\tthis._position = newPos;\n\t\t\tthis._positionChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newPos;\n\t}\n\tget positionMatrix() {\n\t\tif (this._positionChanged) {\n\t\t\tthis._positionMatrix = Mat4.fromPosition(this._position);\n\t\t\tthis._positionChanged = false;\n\t\t}\n\t\treturn this._positionMatrix;\n\t}\n\n\n\t/** @return {Vec3} The local angles, not including any rotation from the parent. */\n\tget rotation() { return this._rotation; }\n\tset rotation(newRot) {\n\t\tif (newRot instanceof Vec3) {\n\t\t\tthis._rotation = newRot;\n\t\t\tthis._rotationChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newRot;\n\t}\n\tget rotationMatrix() {\n\t\tif (this._rotationChanged) {\n\t\t\tthis._rotationMatrix = Mat4.fromEuler(this._rotation, \"XYZ\");\n\t\t\tthis._rotationChanged = false;\n\t\t}\n\t\treturn this._rotationMatrix;\n\t}\n\n\t/** @return {Vec3} The local scale, which is multiplied with the parent's. */\n\tget scale() { return this._scale; }\n\tset scale(newScale) {\n\t\tif (newScale instanceof Vec3) {\n\t\t\tthis._scale = newScale;\n\t\t\tthis._scaleChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newScale;\n\t}\n\tget scaleMatrix() {\n\t\tif (this._scaleChanged) {\n\t\t\tthis._scaleMatrix = Mat4.fromScale(this._scale);\n\t\t\tthis._scaleChanged = false;\n\t\t}\n\t\treturn this._scaleMatrix;\n\t}\n\n\t/** The local offset from the paren't axis/origin */\n\tget localTransform() {\n\t\tif (this._localTransformChanged) {\n\t\t\tthis._localTransform = (\n\t\t\t\tthis.positionMatrix.multiply(\n\t\t\t\tthis.rotationMatrix.multiply(\n\t\t\t\tthis.scaleMatrix\n\t\t\t)));\n\t\t\tthis._localTransformChanged = false;\n\t\t}\n\t\treturn this._localTransform;\n\t}\n\n\t/**\n\t * @return {Mat4} The final transformation matrix for this node \n\t */\n\tget worldTransform() {\n\t\tif (!(this.parentFlags & (PARENTFLAG.POSITION | PARENTFLAG.ROTATION | PARENTFLAG.SCALE)))\n\t\t\treturn this.localTransform;\n\n\t\tlet parentTransform = undefined;\n\t\tif ((this.parentFlags & PARENTFLAG.POSITION) && (this.parentFlags & PARENTFLAG.ROTATION) && (this.parentFlags & PARENTFLAG.SCALE)) {\n\t\t\tparentTransform = this._parentTransform || new Mat4();\n\t\t}\n\t\telse {\n\t\t\tparentTransform = new Mat4();\n\t\t\tif (this.parentFlags & PARENTFLAG.POSITION)\n\t\t\t\tparentTransform.multiply(this.parentNode.positionMatrix);\n\t\t\tif (this.parentFlags & PARENTFLAG.ROTATION)\n\t\t\t\tparentTransform.multiply(this.parentNode.rotationMatrix);\n\t\t\tif (this.parentFlags & PARENTFLAG.SCALE)\n\t\t\t\tparentTransform.multiply(this.parentNode.scaleMatrix);\n\t\t}\n\t\treturn parentTransform.multiply(this.localTransform);\n\t}\n\n\t/**\n\t * @param [parentTransform] {Mat4} - The parent's final transformation matrix\n\t */\n\tupdate(parentTransform) {\n\t\tthis._inheritExternalChanges();\n\n\t\tthis._parentTransform = parentTransform\n\t\tlet finalTransform = this.worldTransform;\n\n\t\tif (this !== _rootNode) {\n\t\t\tif (!this.layer) {\n\t\t\t\t// This node's layer no longer exists, so remove this node from the tree.\n\t\t\t\treturn this.destruct();\n\t\t\t}\n\n\t\t\tthis._lastOrigin = this.layer.origin = finalTransform.toPosition();\n\t\t\tthis._lastAngles = this.layer.angles = finalTransform.toEuler(\"XYZ\");\n\t\t\tthis._lastScale = this.layer.scale = finalTransform.toScale();\n\t\t\tif (this.parentFlags & PARENTFLAG.VISIBILITY)\n\t\t\t\tthis.layer.visible = this.parentNode.layer.visible;\n\t\t}\n\n\t\t// update our children\n\t\tfor (const child of this.children) {\n\t\t\tchild.update(finalTransform);\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether any external source(s) altered properties of the layer since our last update, and updates the node state accordingly.\n\t */\n\t_inheritExternalChanges() {\n\t\tlet message = \"\";\n\t\tif (this !== _rootNode) {\n\t\t\tlet parentLayer = this.parentNode.layer;\n\t\t\tif (this._lastOrigin !== undefined && !OMGVector.equal(this.layer.origin, this._lastOrigin)) {\n\t\t\t\tthis.position = this.layer.origin.subtract(parentLayer.origin).divide(parentLayer.scale);\n\t\t\t\tif (scriptProperties.debug)\n\t\t\t\t\tmessage += `${this.name} position changed from ${this._lastOrigin} to ${this.layer.origin}\\n`;\n\t\t\t}\n\t\t\tif (this._lastAngles!== undefined && !OMGVector.equal(this.layer.angles, this._lastAngles)) {\n\t\t\t\tthis.rotation = this.layer.angles.subtract(parentLayer.angles);\n\t\t\t\tif (scriptProperties.debug)\n\t\t\t\t\tmessage += `${this.name} rotation changed from ${this._lastAngles} to ${this.layer.angles}\\n`;\n\t\t\t}\n\t\t\tif (this._lastScale !== undefined && !OMGVector.equal(this.layer.scale, this._lastScale)) {\n\t\t\t\tthis.scale = this.layer.scale.divide(parentLayer.scale);\n\t\t\t\tif (scriptProperties.debug)\n\t\t\t\t\tmessage += `${this.name} scale changed from ${this._lastScale} to ${this.layer.scale}\\n`;\n\t\t\t}\n\t\t}\n\t\tif (scriptProperties.debug && message !== \"\") {\n\t\t\tconsole.log(message);\n\t\t\tif (scriptProperties.printToScreen)\n\t\t\t\tHelpers.debugText(`LayerParenting_inheritExternalChanges_${this.name}`, message, 10000);\n\t\t}\n\t}\n\n\t/** \n\t * Sets the parent of this node.\n\t * @param parentNode {LayerTreeNode} - This node's new parent node.\n\t */\n\tsetParent(parentNode) {\n\t\tif (parentNode === _rootNode && this.children.length === 0)\n\t\t\tthis.destruct();\n\t\telse if (parentNode !== this.parentNode) {\n\t\t\tthis.parentNode.removeChild(this);\n\t\t\tparentNode.addChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Detaches this node from its current parent node.\n\t */\n\tunparent() {\n\t\tthis.parentNode.removeChild(this, false);\n\t}\n\n\taddChild(childNode) {\n\t\tif (childNode instanceof LayerTreeNode) {\n\t\t\tchildNode.parentNode = this;\n\t\t\tthis.children.push(childNode);\n\t\t}\n\t}\n\n\t/** \n\t * Detaches the given child node from this node, and attaches it to this node's parent. \n\t * @param childNode {LayerTreeNode} the child node to be detached.\n\t */\n\tremoveChild(childNode, attachtoParent = true) {\n\t\tchildIndex = this.children.indexOf(childNode);\n\t\tif (childIndex !== -1) {\n\t\t\tif (attachtoParent)\n\t\t\t\tchildNode.setParent(this.parentNode);\n\t\t\telse\n\t\t\t\tchildNode.setParent(_rootNode);\n\t\t\tthis.children.splice(childIndex, 1);\n\t\t}\n\t}\n\tremoveChildren() { for(const child of this.children) this.removeChild(child); }\n\n\ttoString() {\n\t\treturn `${this.name}`;\n\t}\n}\n_rootNode = new LayerTreeNode({layer: undefined, parentFlags: PARENTFLAG.NONE});\n\n/**\n * Returns the node for a given layer if it exists, or undefined if no node exists yet.\n * @return {LayerTreeNode}\n */\nfunction getNode(layer) {\n\treturn _treeDirectory.get(layer);\n}\n\nclass LayerParenting {\n\tstatic update(){\n\t\t_rootNode.update();\n\t}\n\n\t/**\n\t * Attaches a child layer to a parent layer, causing it to move and rotate along with the parent.\n\t * @param targetLayer {ILayer} - The child layer.\n\t * @param parentLayer {ILayer} - The parent layer.\n\t * @param [parentFlags] {PARENTFLAG} - An optional set of flags enabling or disabling parenting of various layer attributes.\n\t */\n\tstatic setParent(targetLayer, parentLayer, parentFlags = PARENTFLAG.ALL) {\n\t\tif (!targetLayer)\n\t\t\treturn null;\n\t\tif (!parentLayer) {\n\t\t\tunparent(targetLayer);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet targetNode = getNode(targetLayer);\n\t\tlet parentNode = getNode(parentLayer);\n\t\tif (parentNode === undefined) {\n\t\t\tparentNode = new LayerTreeNode({\n\t\t\t\tlayer: parentLayer,\n\t\t\t\tparentFlags: PARENTFLAG.NONE,\n\t\t\t\tposition: parentLayer.origin,\n\t\t\t\trotation: parentLayer.angles,\n\t\t\t\tscale: parentLayer.scale\n\t\t\t\t});\n\t\t}\n\t\tif (targetNode === undefined) {\n\t\t\ttargetNode = new LayerTreeNode({\n\t\t\t\tlayer: targetLayer,\n\t\t\t\tparentNode: parentNode,\n\t\t\t\tparentFlags: parentFlags,\n\t\t\t\tposition: targetLayer.origin.subtract(parentLayer.origin).divide(parentLayer.scale),\n\t\t\t\trotation: targetLayer.angles.subtract(parentLayer.angles),\n\t\t\t\tscale: targetLayer.scale.divide(parentLayer.scale)\n\t\t\t\t});\n\t\t}\n\t\telse if (targetNode.parentNode === parentNode) {\n\t\t\ttargetNode.parentFlags = parentFlags;\n\t\t\treturn parentLayer;\n\t\t}\n\t\telse {\n\t\t\ttargetNode.setParent(parentNode);\n\t\t}\n\t\t\n\t\tif (scriptProperties.debug) {\n\t\t\tlet message = `Parenting ${targetNode.name} to ${parentNode.name} \\n` +\n\t\t\t              `Local position: ${targetNode.position} \\n` + \n\t\t\t              `Local scale: ${targetNode.scale}`;\n\t\t\tconsole.log(message);\n\t\t\tif (scriptProperties.printToScreen) {\n\t\t\t\tHelpers.debugText(`LayerParenting_setParent_${targetNode.name}`, message, 8000);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns the node for a given layer if it exists, or undefined if no node exists yet.\n\t * @return {LayerTreeNode}\n\t */\n\tstatic getNode(layer) { return getNode(layer); }\n\n\t/** Detaches the given layer from its parent. Does not detach any children from the given layer. */\n\tstatic unparent(childLayer) {\n\t\tlet node = getNode(childLayer)\n\t\tif (node)\n\t\t\tnode.unparent();\n\t}\n}\nshared.LayerParenting = LayerParenting;",
				"scriptproperties" : 
				{
					"debug" : false,
					"debug_nodeCreation" : false,
					"printToScreen" : false
				},
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 12,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Interpolators (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n// This system allows you to create interpolator objects which will change a property on a given\n// layer over time. There are different types of interpolators each with different behaviors.\n// Created by OMGparticles, 2021\n// If you find this, feel free to use it in your own project. It may have issues, but has worked \n// well enough for my personal projects.\n\nconst Helpers = shared.OMGHelpers;\n\nshared.timeNudge = 0;\n\n/** @type {Interpolator[]} */\nlet activeInterps = [];\n\n\nexport function update() {\n\tactiveInterps.forEach((interp, index, array) => {\n\t\tinterp.update(engine.frametime + (shared.timeNudge || 0));\n\t});\n\tshared.timeNudge = 0;\n}\n\n\n\n\n/** Modifies an object property over a period of time */\nclass Interpolator {\n/** \n * @typedef {Object} InterpolatorParams\n * @property targetObject {object} - The object whose property value will be modified\n * @property propertyName {String} - The name of the property key to be modified\n * @property duration {Number} - How long it will take to reach the final value.\n * @property startValue {object} - An optional starting value. If not set, will use the properties existing value.\n * @property startOffset {object} - An optional offset to the starting value.\n * @property endValue {object} - The value the target variable will reach at the end of the duration. If not set, will use the properties existing value.\n * @property endOffset {object} - An optional offset to the end value.\n */\n\t/** \n\t * @param {InterpolatorParams} params - Object which allows parameters to be set by name. \n\t */\n\tconstructor(params) {\n\t\tthis.targetObject = params.targetObject;\n\t\tthis.propertyName = params.propertyName || \"origin\";\n\t\tthis.duration = params.duration || 1.0;\n\t\tthis.elapsedTime = 0;\n\t\tactiveInterps.push(this);\n\t\t\n\t\tif (params.startValue !== undefined)\n\t\t\tthis.startValue = Helpers.add(params.startValue, params.startOffset);\n\t\telse\n\t\t\tthis.startValue = Helpers.add(this.targetValue, params.startOffset);\n\t\tthis.targetValue = this.startValue;\n\t\t\n\t\tif (params.endValue !== undefined)\n\t\t\tthis.endValue = Helpers.add(params.endValue, params.endOffset);\n\t\telse\n\t\t\tthis.endValue = Helpers.add(this.targetValue, params.endOffset);\n\t}\n\n\t/** \n\t * Returns an array of interpolators currently affecting the given object \n\t */\n\tstatic getInterpolators(targetObject) {\n\t\tif (targetObject !== undefined)\n\t\t{\n\t\t\tlet targetInterps = [];\n\t\t\tfor (let i of activeInterps) {\n\t\t\t\tif (i.targetObject === targetObject)\n\t\t\t\t\ttargetInterps.push(i);\n\t\t\t}\n\t\t\treturn targetInterps;\n\t\t}\n\t\telse\n\t\t\treturn activeInterps;\n\t}\n\n\t/**\n\t * Instantly destroys alls interpolators affecting the target object\n\t */\n\tstatic clearInterpolators(targetObject) {\n\t\tlet interps = undefined;\n\t\tif (targetObject !== undefined)\n\t\t\tinterps = Interpolator.getInterpolators(targetObject) || [];\n\t\telse\n\t\t\tinterps = activeInterps;\n\t\tfor (let i of interps)\n\t\t\ti.destroy();\n\t}\n\n\tstatic finishInterpolators(targetObject) {\n\t\tlet interps = undefined;\n\t\tif (targetObject !== undefined)\n\t\t\tinterps = Interpolator.getInterpolators(targetObject) || [];\n\t\telse\n\t\t\tinterps = activeInterps;\n\t\tfor (let i of interps) { \n\t\t\ti.finish();\n\t\t\ti.destroy();\n\t\t}\n\t}\n\n\tget targetValue() {return this.targetObject[this.propertyName]}\n\tset targetValue(newValue) {return this.targetObject[this.propertyName] = newValue}\n\n\tupdate(dt) {\n\t\tthis.elapsedTime += dt;\n\t\tif (this.elapsedTime > this.duration) {\n\t\t\tthis.finish();\n\t\t\tthis.destroy();\n\t\t}\n\t\telse\n\t\t\tthis.interpolate();\n\t}\n\n\tinterpolate() {\n\t\t// Perform interpolation here\n\t}\n\n\t/** Performs any final adjustments before this interpolator expires. */ \n\tfinish() {\n\t\tthis.targetValue = this.endValue;\n\t}\n\n\tdestroy() {\n\t\tactiveInterps.splice(activeInterps.indexOf(this), 1);\n\t}\n}\nshared.Interpolator = new Object();\nshared.Interpolator.getInterpolators = Interpolator.getInterpolators;\nshared.Interpolator.clearInterpolators = Interpolator.clearInterpolators;\nshared.Interpolator.finishInterpolators = Interpolator.finishInterpolators;\n\n\n/** Transitions from the start to end value at a constant rate. */\nclass LinearInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, percentage);\n\t}\n}\nshared.LinearInterp = LinearInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseOutInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, percentage * (2 - percentage));\n\t}\n}\nshared.EaseOutInterp = EaseOutInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseOutStrongInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, Math.pow(percentage-1, 3) + 1);\n\t}\n}\nshared.EaseOutStrongInterp = EaseOutStrongInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseInInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, Math.pow(percentage, 2));\n\t}\n}\nshared.EaseInInterp = EaseInInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first, quickly in the middle, then slow again at the end. */\nclass EaseInOutInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet x = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, x * x * (3 - 2 * x));\n\t}\n}\nshared.EaseInOutInterp = EaseInOutInterp;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 15,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Shared logic (script)",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/** \n * Coordinates that correspond to the horizontal extents of the visible part of the wallpaper based on the current display's aspect ratio. \n * @type Vec2\n*/\nshared.screenBoundsX = undefined;\n/** \n * Canvas coordinates that correspond to the vertical extents of the visible part of the wallpaper based on the current display's aspect ratio. \n * @type Vec2\n*/\nshared.screenBoundsY = undefined;\n\n/** \n * Multiply scale by this value to make sure an object's pixel dimensions do not change when the screen dimensions change.\n * @type number\n */\nshared.canvasToScreen = undefined;\n\n/**\n * Used to scale up certain UI elements on large screen resolutions.\n * @type number\n */\nshared.zoom = undefined;\n\n/** Horizontal offset for the title card and buttons. Used when transitioning to other menus. */\nshared.globalXOffset = 0;\n\n/** Global scale multiplier for UI elements. */\nshared.ui_scale = 1;\n\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tshared.canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n\t\n\tshared.zoom = engine.screenResolution.y < 800 || engine.screenResolution.x < 1200 ? 2 : 3;\n\n\tlet screenAspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\tlet canvasAspectRatio = engine.canvasSize.x / engine.canvasSize.y;\n\tif (screenAspectRatio > canvasAspectRatio) {\n\t\tlet height = engine.screenResolution.y * engine.canvasSize.x / engine.screenResolution.x;\n\t\tlet cornerOffset = (engine.canvasSize.y - height) / 2;\n\t\tshared.screenBoundsX = new Vec2(0, engine.canvasSize.x);\n\t\tshared.screenBoundsY = new Vec2(cornerOffset, engine.canvasSize.y - cornerOffset);\n\t}\n\telse {\n\t\tlet width = engine.screenResolution.x * engine.canvasSize.y / engine.screenResolution.y;\n\t\tlet cornerOffset = (engine.canvasSize.x - width) / 2;\n\t\tshared.screenBoundsX = new Vec2(cornerOffset, engine.canvasSize.x - cornerOffset);\n\t\tshared.screenBoundsY = new Vec2(0, engine.canvasSize.y);\n\t}\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tif (changedUserProperties.ui_scale !== undefined) {\n\t\tshared.ui_scale = changedUserProperties.ui_scale;\n\t}\n}\n\n\n\n\n// shared.viewportY = 0;\n// let viewportDY = 0.01;\n\n// export function init() {\n// }\n\n\n// export function update() {\n// \tshared.viewportY += viewportDY;\n// \tif (viewportDY > 0.0)\n// \t\tviewportDY += 3.0/500.0;\n// \tif (shared.viewportY > 1000.0) {\n// \t\tif (viewportDY != 0.0) {\n// \t\t\t// stuff\n// \t\t}\n// \t\tviewportDY = 0.0;\n// \t}\n\t\t\n// }",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 13,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Audio Manager (script)",
			"origin" : "1920.00000 1080.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addCheckbox({\n\t\tname: 'debug_audio',\n\t\tlabel: 'Debug Audio',\n\t\tvalue: false\n\t})\n\t.finish();\n\nconst Helpers = shared.OMGHelpers;\n\n// const ScenePhase = shared.ScenePhase || function() {return shared.ScenePhase};\n// const SceneManager = shared.SceneManager || function() {return shared.SceneManager};\n\n// These values aren't defined yet, but assigning them here gives us intellisense.\n// We assign the actual class pointers in init().\nlet ScenePhase = shared.ScenePhase; \nlet SceneManager = shared.SceneManager;\n\nlet _a_TitleMusic = engine.registerAsset(\"sounds/MainTheme.ogg\");\nlet _a_TitleAmbient = engine.registerAsset(\"sounds/spring_day_ambient.ogg\");\nlet _music = undefined;\nlet _ambient_volume = undefined;\n\nconst _musicRepeatDelay = 146;\nconst _fadeDuration = 1.0;\nlet _currentTime = new Date().getTime();\n\n/** @type MusicLayer[] */\nlet _activeMusic = [];\n/** @type AmbienceLayer[] */\nlet _activeAmbience = [];\n/** @type SoundLayer[] */\nlet _activeSounds = [];\n\n\n\nexport function init(value) {\n\tScenePhase = shared.ScenePhase;\n\tSceneManager = shared.SceneManager;\n}\n\n\nexport function update(value) {\n\tAudioManager.update();\n}\n\n\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.music != undefined && userProperties.music != _music) {\n\t\t_music = userProperties.music;\n\t\tif (SceneManager.phase === ScenePhase.MAIN || SceneManager.phase === ScenePhase.MAIN.INTRO) {\n\t\t\tAudioManager.stopMusic();\n\t\t\tAudioManager.startMusic(_music);\n\t\t}\n\t}\n\tif (userProperties.ambient_volume != undefined && userProperties.ambient_volume != _ambient_volume) {\n\t\t_ambient_volume = userProperties.ambient_volume;\n\t}\n}\n\n\n/** Can start and stop sounds and loop music dynamically. */\nclass AudioManager {\n\tstatic update() {\n\t\t_currentTime = new Date().getTime();\n\n\t\t// Update active sounds\n\t\t_activeSounds.forEach(\n\t\t\tfunction(soundLayer, index, array) {\n\t\t\t\tsoundLayer.update();\n\t\t\t\tif (soundLayer.isDone) {\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\n\t\t// Update active music\n\t\t_activeMusic.forEach(\n\t\t\tfunction(musicLayer, index, array) {\n\t\t\t\tmusicLayer.update();\n\t\t\t\tif (musicLayer.isDone) {\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Update active music\n\t\t_activeAmbience.forEach(\n\t\t\tfunction(ambientLayer, index, array) {\n\t\t\t\tambientLayer.update();\n\t\t\t\tif (ambientLayer.isDone) {\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Print debug info to screen\n\t\tif (scriptProperties.debug_audio)\n\t\t{\n\t\t\tif (_activeMusic.length > 0)\n\t\t\t{\n\t\t\t\tHelpers.debugText(\"MusicHeader\", \"Music:\");\n\t\t\t\tfor (let musicLayer of _activeMusic) {\n\t\t\t\t\tlet musicTime = new Date(null);\n\t\t\t\t\tif (musicLayer.startTime)\n\t\t\t\t\t\tmusicTime.setSeconds((_currentTime - musicLayer.startTime) / 1000.0);\n\t\t\t\t\tmusicTime = musicTime.toISOString().substr(14, 5);\n\t\t\t\t\tlet isPlaying = musicLayer.isPlaying ? \"Playing\" : \"Not Playing\";\n\t\t\t\t\tHelpers.debugText(musicLayer.name, `${musicLayer.name} (${isPlaying}) - ${musicTime}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_activeAmbience.length > 0)\n\t\t\t{\n\t\t\t\tHelpers.debugText(\"ambientHeader\", \"Ambience:\");\n\t\t\t\tfor (let ambientLayer of _activeAmbience) {\n\t\t\t\t\tlet ambientTime = new Date(null);\n\t\t\t\t\tif (ambientLayer.startTime)\n\t\t\t\t\t\tambientTime.setSeconds((_currentTime - ambientLayer.startTime) / 1000.0);\n\t\t\t\t\tambientTime = ambientTime.toISOString().substr(14, 5);\n\t\t\t\t\tlet isPlaying = ambientLayer.isPlaying ? \"Playing\" : \"Not Playing\";\n\t\t\t\t\tHelpers.debugText(ambientLayer.name, `${ambientLayer.name} (${isPlaying}) - ${ambientTime}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_activeSounds.length > 0)\n\t\t\t{\n\t\t\t\tHelpers.debugText(\"SoundHeader\", \"Sounds:\");\n\t\t\t\tfor (let soundLayer of _activeSounds) {\n\t\t\t\t\tlet isPlaying = soundLayer.isPlaying ? \"Playing\" : \"Not Playing\";\n\t\t\t\t\tHelpers.debugText(soundLayer.name, `${soundLayer.name} (${isPlaying})`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic isSoundPlaying() {\n\t\treturn _activeSounds.some(soundLayer => soundLayer.isPlaying);\n\t}\n\n\tstatic isMusicPlaying() {\n\t\treturn _activeMusic.some(musicLayer => musicLayer.isPlaying);\n\t}\n\n\tstatic isAmbiencePlaying() {\n\t\treturn _activeAmbience.some(ambientLayer => ambientLayer.isPlaying);\n\t}\n\n\n\t/** Starts fading out all active music */\n\tstatic stopMusic() {\n\t\tfor (const musicLayer of _activeMusic)\n\t\t\tmusicLayer.startFade();\n\t}\n\n\tstatic stopAmbience() {\n\t\tfor (const ambienceLayer of _activeAmbience)\n\t\t\tambienceLayer.startFade();\n\t}\n\n\t/** Begins looping the given music track. */\n\tstatic startMusic(music = _music) {\n\t\tlet newMusic = undefined;\n\n\t\tswitch (music) {\n\t\tdefault:\n\t\t\tnewMusic = new MusicLayer(_a_TitleMusic, 0.8, _musicRepeatDelay);\n\t\t\tbreak;\n\t\tcase \"None\":\n\t\t\tbreak;\n\t\t}\n\n\t\treturn newMusic;\n\t}\n\n\t/** Begins looping the ambience track. */\n\tstatic startAmbience() {\n\t\treturn new AmbientLayer(_a_TitleAmbient, _ambient_volume * 0.01, _musicRepeatDelay);\n\t}\n\n\t/** Plays a single sound\n\t * @returns {SoundLayer} The created sound layer\n\t */\n\tstatic playSound(asset, volume = 0.5) {\n\t\treturn new SoundLayer(asset, volume);\n\t}\n}\nshared.AudioManager = AudioManager;\n\n\n\nclass AudioLayer {\n\tconstructor(asset, volume = 0.5) {\n\t\tthis.asset = asset;\n\t\tthis._layer = thisScene.createLayer({\n\t\t\tname: asset,\n\t\t\tsound: asset,\n\t\t\tvolume: Math.max(volume, 0.001), // Give it some volume or the layer might not be created\n\t\t\tstartsilent: true\n\t\t});\n\t\t// let layerSettings = new Object();\n\t\t// layerSettings.name = asset;\n\t\t// layerSettings.sound = asset;\n\t\t// layerSettings.volume = Math.max(volume, 0.001);\n\t\t// layerSettings.startsilent = true;\n\t\t// this._layer = thisScene.createLayer(layerSettings);\n\t\tthis.register();\n\t}\n\n\tget name() {return this._layer.name}\n\tget volume() {return this._layer.volume}\n\tset volume(val) {return this._layer.volume = val}\n\tpause() {this._layer.pause()}\n\tstop() {this._layer.stop()}\n\tplay() {this._layer.play()}\n\tget isPlaying() {return this._layer.isPlaying()}\n\n\tregister() {_activeSounds.push(this);}\n\n\tupdate() {}\n\n\tdestroy() {\n\t\tthis.isDone = true;\n\t\t//this.stop();\n\t\tengine.setTimeout( ()=>{thisScene.destroyLayer(this._layer);} , 100); // Destroy layer after a short delay since there seems to be some buffering involved that cuts sounds off early\n\t}\n}\n\n\n/** Plays the given sound asset once, then destroys itself. */\nclass SoundLayer extends AudioLayer{\n\tconstructor(asset, volume = 0.5) {\n\t\tsuper(asset, volume);\n\t\tthis._layer.playbackmode = \"single\";\n\t\tthis.hasPlayed = false;\n\t}\n\n\tupdate() {\n\t\t// Delayed start to prevent audio hiccups\n\t\tif (!this.isPlaying) {\n\t\t\tif (!this.hasPlayed) {\n\t\t\t\tthis._layer.play();\n\t\t\t\tthis.hasPlayed = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n/** Audio layer that crossfade loops itself after the specified repeat delay */\nclass MusicLayer extends AudioLayer{\n\tconstructor(asset, volume = 0.5, repeatDelay = 9999){\n\t\tsuper(asset, volume);\n\t\tthis.unfadedVolume = volume;\n\t\tthis._layer.playbackmode = \"single\";\n\t\t/** How many seconds to play before the track loops */\n\t\tthis.repeatDelay = repeatDelay;\n\t\t/** The track will fade out for this many seconds whenever it loops */\n\t\tthis.fadeDuration = _fadeDuration;\n\t}\n\t\n\tset volume(val) {this.unfadedVolume = val}\n\tget volume() {return this.unfadedVolume}\n\tget isPlaying() {return (this.startTime && !this.bFadingOut && this._layer.isPlaying())}\n\n\tregister() { _activeMusic.push(this); }\n\n\tupdate() {\n\t\t// Fade out then kill layer\n\t\tif (this.bFadingOut) {\n\t\t\tif (_currentTime > this.fadeEndTime) {\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet fadeLerp = (_currentTime - this.fadeStartTime) / (this.fadeEndTime - this.fadeStartTime);\n\t\t\t\tthis._layer.volume = Helpers.lerp(this.unfadedVolume, 0, fadeLerp);\n\t\t\t}\n\t\t}\n\t\t// Delayed start to prevent audio hiccups\n\t\telse if (!this._layer.isPlaying() && this.startTime === undefined) {\n\t\t\tthis._layer.play();\n\t\t\t// If the wallpaper is muted when the music starts, it won't be able to play. Keep trying until it is unmuted.\n\t\t\tif (this._layer.isPlaying())\n\t\t\t{\n\t\t\t\tthis.startTime = _currentTime;\n\t\t\t\tthis.endTime = this.startTime + this.repeatDelay * 1000;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Update volume\n\t\t\tthis._layer.volume = this.unfadedVolume;\n\n\t\t\t// Start new audio\n\t\t\tif (_currentTime > this.endTime) {\n\t\t\t\tthis.loop();\n\t\t\t}\n\t\t}\n\t}\n\n\tstartFade() {\n\t\tif (!this.bFadingOut) {\n\t\t\tthis.bFadingOut = true;\n\t\t\tthis.fadeStartTime = _currentTime;\n\t\t\tthis.fadeEndTime = _currentTime + this.fadeDuration * 1000;\n\t\t}\n\t}\n\n\tloop() {\n\t\tthis.startFade();\n\t\tlet newLayer = new MusicLayer(this.asset, this.unfadedVolume);\n\t\tnewLayer.repeatDelay = this.repeatDelay;\n\t\tnewLayer.volume = this.unfadedVolume;\n\t}\n}\n\nclass AmbientLayer extends MusicLayer {\n\tconstructor(asset, volume = 0.5, repeatDelay = 9999){ super(asset, volume, repeatDelay); }\n\tregister() { _activeAmbience.push(this); }\n\n\tupdate() {\n\t\tsuper.update();\n\t\tthis.volume = Math.max(_ambient_volume * 0.01, 0.001);\n\t}\n\n\tloop() {\n\t\tthis.startFade();\n\t\tlet newLayer = new AmbientLayer(this.asset);\n\t\tnewLayer.repeatDelay = this.repeatDelay;\n\t\tnewLayer.volume = this.unfadedVolume;\n\t}\n}",
				"scriptproperties" : 
				{
					"debug_audio" : false
				},
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 14,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Scene Manager (script)",
			"origin" : "1920.00000 1080.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "100.00000 100.00000 1.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addCheckbox({\n\t\tname: 'debug_ScenePhase',\n\t\tlabel: 'Debug Scene Phase',\n\t\tvalue: false\n\t})\n\t.finish();\n\n\t\nconst Helpers = shared.OMGHelpers;\nconst AudioManager = shared.AudioManager;\nconst LinearInterp = shared.LinearInterp;\nconst EaseOutInterp = shared.EaseOutInterp;\nconst EaseOutStrongInterp = shared.EaseOutStrongInterp;\nconst EaseInInterp = shared.EaseInInterp;\nconst EaseInOutInterp = shared.EaseInOutInterp;\nconst LayerParenting = shared.LayerParenting;\nconst Interpolator = shared.Interpolator;\n\nlet show_developer_splash = undefined;\nlet show_intro = undefined;\nlet show_menu_buttons = undefined;\nshared.viewportY = 0;\n\n\n// Register audio\nlet a_mouseClick = engine.registerAsset(\"sounds/mouseclick.ogg\");\nlet a_cowboyGunshot = engine.registerAsset(\"sounds/Cowboy_gunshot.ogg\");\n\n\n// \"Private variables\"\nlet activePhase = undefined;\nlet phaseTime = 0.0;\nlet phaseProgress = 0.0;\n\n\nconst ScenePhase = {\n\tSPLASH : {\n\t\tname : \"Splash\",\n\t\tlength : 7.0,\n\t\ttimeLine : [\n\t\t\t{\n\t\t\t\ttime : 0,\n\t\t\t\texecute() {\n\t\t\t\t\tif (Math.random() < 0.5) {\n\t\t\t\t\t\tthisScene.getLayer(\"ConcernedApe Closed Eyes\").visible = true;\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe Closed Eyes\"),\n\t\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\t\tstartValue: 0,\n\t\t\t\t\t\t\tendValue: 1,\n\t\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthisScene.getLayer(\"ConcernedApe Sunglasses\").visible = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthisScene.getLayer(\"ConcernedApe Sunglasses\").visible = true;\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe Sunglasses\"),\n\t\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\t\tstartValue: 0,\n\t\t\t\t\t\t\tendValue: 1,\n\t\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthisScene.getLayer(\"ConcernedApe Closed Eyes\").visible = false;\n\t\t\t\t\t}\n\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe Text\"),\n\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\tstartValue: 0,\n\t\t\t\t\t\tendValue: 1,\n\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttime: 1,\n\t\t\t\texecute() {\tAudioManager.playSound(a_mouseClick, 1); }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttime: 2.5,\n\t\t\t\texecute() {\tAudioManager.playSound(a_mouseClick, 1); }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttime: 3,\n\t\t\t\texecute() {\tAudioManager.playSound(a_mouseClick, 1); }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttime: 5,\n\t\t\t\texecute() {\n\t\t\t\t\tif (thisScene.getLayer(\"ConcernedApe Closed Eyes\").visible === true) {\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe Closed Eyes\"),\n\t\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\t\tstartValue: 1,\n\t\t\t\t\t\t\tendValue: 0,\n\t\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if(thisScene.getLayer(\"ConcernedApe Sunglasses\").visible === true) {\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe Sunglasses\"),\n\t\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\t\tstartValue: 1,\n\t\t\t\t\t\t\tendValue: 0,\n\t\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"ConcernedApe Text\"),\n\t\t\t\t\t\tpropertyName: \"alpha\",\n\t\t\t\t\t\tstartValue: 1,\n\t\t\t\t\t\tendValue: 0,\n\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tupdate : function() {\n\t\t\tconst thisPhase = ScenePhase.SPLASH;\n\t\t\twhile (thisPhase.nextEvent < thisPhase.timeLine.length && phaseTime > thisPhase.timeLine[thisPhase.nextEvent].time) {\n\t\t\t\tthisPhase.timeLine[thisPhase.nextEvent].execute();\n\t\t\t\t++thisPhase.nextEvent;\n\t\t\t}\n\t\t},\n\t\tinit : function() {\n\t\t\tAudioManager.stopMusic();\n\t\t\tAudioManager.stopAmbience();\n\t\t\tScenePhase.SPLASH.nextEvent = 0;\n\n\t\t\tthisScene.getLayer(\"ConcernedApe Text\").visible = true;\n\t\t\tthisScene.getLayer(\"Splash White Fade\").visible = true;\n\t\t\tthisScene.getLayer(\"Splash White Fade\").alpha = 1;\n\t\t\tthisScene.getLayer(\"Splash Glow Fade\").getEffect(0).getMaterial(3).compositealpha = 2;\n\t\t\tif (shared.extra_effects === true && shared.sky_glow === true) {\n\t\t\t\tthisScene.getLayer(\"Splash Glow Fade\").visible = true;\n\t\t\t\tthisScene.getLayer(\"Masked Sky Glow\").visible = true;\n\t\t\t}\n\n\t\t\tthisScene.getLayer(\"Skip Button\").visible = true;\n\t\t\tthisScene.getLayer(\"Skip Button\").solid = true;\n\t\t},\n\t\tend : function() {\n\t\t},\n\t\texit : function() {\n\t\t\tnew LinearInterp({\n\t\t\t\ttargetObject: thisScene.getLayer(\"Splash White Fade\"),\n\t\t\t\tpropertyName: \"alpha\", \n\t\t\t\tstartValue: 1,\n\t\t\t\tendValue: 0,\n\t\t\t\tduration: 2\n\t\t\t});\n\t\t\tnew EaseOutInterp({\n\t\t\t\ttargetObject: thisScene.getLayer(\"Splash Glow Fade\").getEffect(0).getMaterial(3),\n\t\t\t\tpropertyName: \"compositealpha\",\n\t\t\t\tstartValue: 2,\n\t\t\t\tendValue: 0,\n\t\t\t\tduration: 4\n\t\t\t});\n\n\t\t\tthisScene.getLayer(\"ConcernedApe Closed Eyes\").alpha = 0;\n\t\t\tthisScene.getLayer(\"ConcernedApe Sunglasses\").alpha = 0;\n\t\t\t//shared.Interpolator.clearInterpolators(thisScene.getLayer(\"ConcernedApe Text\"));\n\t\t\tthisScene.getLayer(\"ConcernedApe Text\").alpha = 0;\n\t\t},\n\t\tget nextPhase() {return (show_intro ? ScenePhase.MAIN.INTRO : ScenePhase.MAIN)}\n\t},\n\n\n\n\tMAIN : {\n\t\tINTRO : {\n\t\t\tname : \"Main.Intro\",\n\t\t\tlength : 16.9,\n\t\t\ttimeLine : [\n\t\t\t\t{\n\t\t\t\t\ttime : 0.0,\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"Bird\"),\n\t\t\t\t\t\t\tpropertyName: \"origin\",\n\t\t\t\t\t\t\tstartValue: new Vec3(shared.screenBoundsX.y - 210 * shared.canvasToScreen, shared.screenBoundsY.x + 390 * shared.canvasToScreen),\n\t\t\t\t\t\t\tendOffset: new Vec3(-6000 * shared.canvasToScreen, 0, 0),\n\t\t\t\t\t\t\tduration: 100.0\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"Bird 2\"),\n\t\t\t\t\t\t\tpropertyName: \"origin\",\n\t\t\t\t\t\t\tstartValue: new Vec3(shared.screenBoundsX.y - 120 * shared.canvasToScreen, shared.screenBoundsY.x + 360 * shared.canvasToScreen),\n\t\t\t\t\t\t\tendOffset: new Vec3(-6000 * shared.canvasToScreen, 0, 0),\n\t\t\t\t\t\t\tduration: 100.0\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 6.0, // Start scrolling\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tnew EaseInInterp({\n\t\t\t\t\t\t\ttargetObject: shared,\n\t\t\t\t\t\t\tpropertyName: \"viewportY\",\n\t\t\t\t\t\t\tstartValue: 0,\n\t\t\t\t\t\t\tendValue: 1000,\n\t\t\t\t\t\t\tduration: 9.9\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 15.9, // Logo grow\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"TitleCard\"),\n\t\t\t\t\t\t\tpropertyName: \"scale\",\n\t\t\t\t\t\t\tendValue: new Vec3((shared.zoom + 0.05) * shared.canvasToScreen),\n\t\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 16.1,\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tif (show_menu_buttons)\n\t\t\t\t\t\t\tthisScene.getLayer(\"Title_New\").visible = true;\n\t\t\t\t\t\tAudioManager.playSound(a_cowboyGunshot);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 16.3,\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tif (show_menu_buttons)\n\t\t\t\t\t\t\tthisScene.getLayer(\"Title_Load\").visible = true;\n\t\t\t\t\t\tAudioManager.playSound(a_cowboyGunshot);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 16.4, // Logo shrink\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tnew LinearInterp({\n\t\t\t\t\t\t\ttargetObject: thisScene.getLayer(\"TitleCard\"),\n\t\t\t\t\t\t\tpropertyName: \"scale\",\n\t\t\t\t\t\t\tendValue: new Vec3(shared.zoom * shared.canvasToScreen),\n\t\t\t\t\t\t\tduration: 0.5\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 16.5,\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tif (show_menu_buttons)\n\t\t\t\t\t\t\tthisScene.getLayer(\"Title_Coop\").visible = true;\n\t\t\t\t\t\tAudioManager.playSound(a_cowboyGunshot);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttime : 16.7,\n\t\t\t\t\texecute() {\n\t\t\t\t\t\tif (show_menu_buttons)\n\t\t\t\t\t\t\tthisScene.getLayer(\"Title_Exit\").visible = true;\n\t\t\t\t\t\tAudioManager.playSound(a_cowboyGunshot);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\t\t\tupdate : function() {\n\t\t\t\tconst thisPhase = ScenePhase.MAIN.INTRO;\n\t\t\t\twhile (thisPhase.nextEvent < thisPhase.timeLine.length && phaseTime > thisPhase.timeLine[thisPhase.nextEvent].time) {\n\t\t\t\t\tthisPhase.timeLine[thisPhase.nextEvent].execute();\n\t\t\t\t\t++thisPhase.nextEvent;\n\t\t\t\t}\n\t\t\t},\n\t\t\tinit : function() {\n\t\t\t\tif (!AudioManager.isMusicPlaying())\n\t\t\t\t\tAudioManager.startMusic();\n\t\t\t\tif (!AudioManager.isAmbiencePlaying())\n\t\t\t\t\tAudioManager.startAmbience();\n\t\t\t\tScenePhase.MAIN.INTRO.nextEvent = 0;\n\n\t\t\t\tshared.viewportY = 0;\n\n\t\t\t\tthisScene.getLayer(\"Title_New\").visible = false;\n\t\t\t\tthisScene.getLayer(\"Title_Load\").visible = false;\n\t\t\t\tthisScene.getLayer(\"Title_Coop\").visible = false;\n\t\t\t\tthisScene.getLayer(\"Title_Exit\").visible = false;\n\n\t\t\t\tthisScene.getLayer(\"Skip Button\").visible = true;\n\t\t\t\tthisScene.getLayer(\"Skip Button\").solid = true;\n\t\t\t},\n\t\t\tend : function() {},\n\t\t\texit : function() {\n\t\t\t\t// Clean up anything that might be out of order if we exit early\n\t\t\t\tshared.viewportY = 1000;\n\t\t\t\tthisScene.getLayer(\"TitleCard\").scale = new Vec3(shared.zoom * shared.canvasToScreen);\n\t\t\t\t\n\t\t\t\tif (show_menu_buttons)\n\t\t\t\t{\n\t\t\t\t\tthisScene.getLayer(\"Title_New\").visible = true;\n\t\t\t\t\tthisScene.getLayer(\"Title_Load\").visible = true;\n\t\t\t\t\tthisScene.getLayer(\"Title_Coop\").visible = true;\n\t\t\t\t\tthisScene.getLayer(\"Title_Exit\").visible = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget nextPhase() {return ScenePhase.MAIN}\n\t\t},\n\n\n\n\t\tname : \"Main\",\n\t\tget nextPhase() {return null},\n\t\tlength : 0.0,\n\t\tupdate : function() {\n\n\t\t},\n\t\tinit : function() {\n\t\t\tif (!AudioManager.isMusicPlaying())\n\t\t\t\tAudioManager.startMusic();\n\t\t\tif (!AudioManager.isAmbiencePlaying())\n\t\t\t\tAudioManager.startAmbience();\n\t\t\tScenePhase.MAIN.nextEvent = 0;\n\n\n\t\t\tshared.viewportY = 1000;\n\t\t\tthisScene.getLayer(\"TitleCard\").scale = new Vec3(shared.zoom * shared.canvasToScreen);\n\t\t\tthisScene.getLayer(\"TitleCard\").visible = true;\n\t\t\t\n\t\t\tif (show_menu_buttons)\n\t\t\t{\n\t\t\t\tthisScene.getLayer(\"Title_New\").visible = true;\n\t\t\t\tthisScene.getLayer(\"Title_Load\").visible = true;\n\t\t\t\tthisScene.getLayer(\"Title_Coop\").visible = true;\n\t\t\t\tthisScene.getLayer(\"Title_Exit\").visible = true;\n\t\t\t}\n\t\t\tthisScene.getLayer(\"Skip Button\").visible = false;\n\t\t\tthisScene.getLayer(\"Skip Button\").solid = false;\n\t\t},\n\t\tend : function() {},\n\t\texit : function() {}\n\t}\n}\nshared.ScenePhase = ScenePhase;\n\nclass SceneManager {\n\tstatic update() {\t\t\n\t\tif (activePhase) {\n\t\t\t// Advance phase\n\t\t\tphaseTime += engine.frametime;\n\t\t\tif (phaseTime > activePhase.length && activePhase.nextPhase) {\n\t\t\t\t// Complete any remaining actions before ending the phase.\n\t\t\t\tactivePhase.update();\n\t\t\t\t// Advance to the next phase.\n\t\t\t\tSceneManager.advancePhase();\n\t\t\t}\n\t\t\tif (activePhase.length !== 0)\n\t\t\t\tshared.phaseProgress = phaseTime / activePhase.length;\n\t\t\telse \n\t\t\t\tshared.phaseProgress = 0.0;\n\n\t\t\t// Update active phase\n\t\t\tif (typeof(activePhase.update) === \"function\")\n\t\t\t\tactivePhase.update();\n\t\t}\n\n\t\t// Helpers.printObjectValues(thisScene.getLayer(\"Splash Glow Fade\").getEffect(0).getMaterial(3));\n\t\t// console.log(thisScene.getLayer(\"Splash Glow Fade\").getEffect(0).getMaterial(3).compositealpha);\n\t\t// thisScene.getLayer(\"Splash Glow Fade\").getEffect(0).getMaterial(3).compositealpha = 0;\n\t}\n\t\n\tstatic get phase() {return activePhase}\n\n\tstatic get phaseTime() {return phaseTime}\n\n/** Ends the current phase and skips to the next one. Any remaining actions are skipped. */\n\tstatic advancePhase() {\n\t\tif (typeof(activePhase.end) === \"function\")\n\t\t\tactivePhase.end();\n\t\tif (activePhase.nextPhase)\n\t\t\tSceneManager.setPhase(activePhase.nextPhase);\n\t}\n\n/** Jumps forward to the end of the current phase, completing any remaining actions in one frame. */\n\tstatic completePhase() {\n\t\tphaseTime = activePhase.length;\n\t\t// Update active phase\n\t\tif (typeof(activePhase.update) === \"function\")\n\t\t\tactivePhase.update();\n\t}\n\n/** Initialize the currently active phase */\n\tstatic setPhase(newPhase, bInit = true) {\n\t\tif (activePhase && typeof(activePhase.exit) === \"function\")\n\t\t\tactivePhase.exit();\n\t\tactivePhase = newPhase;\n\t\tphaseTime = 0;\n\t\tif (bInit && typeof(activePhase.init) === \"function\")\n\t\t\tactivePhase.init();\n\t}\n\n\tstatic skipPressed() {\n\t\tshared.timeNudge = activePhase.length - phaseTime; // Advance any active interpolators.\n\t\tthis.advancePhase(); // Skip to the next phase.\n\t\tAudioManager.playSound(a_cowboyGunshot); // click\n\t}\n}\nshared.SceneManager = SceneManager;\n\n\n\n/** Initialize in update instead of init, since we want to load user settings before we initialize */\nlet bFirstUpdate = true;\n/**\n * @param {Boolean} value (for property 'visible')\n */\nexport function update(value) {\n\tif (bFirstUpdate) {\n\t\tbFirstUpdate = false;\n\n\t\t// Set the initial phase in update(), as init() runs before we get user properties\n\t\tif (show_developer_splash)\n\t\t\tSceneManager.setPhase(ScenePhase.SPLASH);\n\t\telse if (show_intro)\n\t\t\tSceneManager.setPhase(ScenePhase.MAIN.INTRO);\n\t\telse\n\t\t\tSceneManager.setPhase(ScenePhase.MAIN);\n\t}\n\telse\n\t\tSceneManager.update();\n\n\tif (scriptProperties.debug_ScenePhase) {\n\t\tHelpers.debugText(\"scenePhase\", `Phase: ${activePhase.name}`);\n\t\tHelpers.debugText(\"scenePhaseTime\", `Phase time: ${phaseTime}`);\n\t}\n\n\treturn value;\n}\n\n\n\n/**\n * @param {Object} userProperties\n */\nexport function applyUserProperties(userProperties) {\n\tif (userProperties.show_intro !== undefined && userProperties.show_intro !== show_intro) {\n\t\tshow_intro = userProperties.show_intro;\n\t\t// Jump to intro when enabled\n\t\tif (!bFirstUpdate) {\n\t\t\tif (show_intro && activePhase !== ScenePhase.MAIN.INTRO)\n\t\t\t{\n\t\t\t\tshared.Interpolator.finishInterpolators();\n\t\t\t\tSceneManager.setPhase(ScenePhase.MAIN.INTRO);\n\t\t\t}\n\t\t\t// else if (SceneManager.phase === ScenePhase.MAIN.INTRO)\n\t\t\t// \tSceneManager.advancePhase();\n\t\t}\n\t}\n\tif (userProperties.show_developer_splash !== undefined && userProperties.show_developer_splash !== show_developer_splash) {\n\t\tshow_developer_splash = userProperties.show_developer_splash;\n\t\t// Jump to splash screen when enabled\n\t\tif (!bFirstUpdate) {\n\t\t\tif (show_developer_splash && activePhase !== ScenePhase.SPLASH)\n\t\t\t{\n\t\t\t\tshared.Interpolator.finishInterpolators();\n\t\t\t\tSceneManager.setPhase(ScenePhase.SPLASH);\n\t\t\t}\n\t\t}\n\t}\n\tif (userProperties.show_menu_buttons !== undefined) {\n\t\tshow_menu_buttons = userProperties.show_menu_buttons;\n\t\tif (activePhase === ScenePhase.MAIN)\n\t\t{\n\t\t\tthisScene.getLayer(\"Title_New\").visible = \n\t\t\tthisScene.getLayer(\"Title_Load\").visible = \n\t\t\tthisScene.getLayer(\"Title_Coop\").visible = \n\t\t\tthisScene.getLayer(\"Title_Exit\").visible = show_menu_buttons;\n\t\t}\n\t}\n\tif (userProperties.extra_effects !== undefined)\n\t\tshared.extra_effects = userProperties.extra_effects;\n\tif (userProperties.sky_glow !== undefined)\n\t\tshared.sky_glow = userProperties.sky_glow;\n\n\tif (shared.extra_effects === true && shared.sky_glow === true) {\n\t\tthisScene.getLayer(\"Splash Glow Fade\").visible = true;\n\t\tthisScene.getLayer(\"Masked Sky Glow\").visible = true;\n\t}\n\telse {\n\t\tthisScene.getLayer(\"Splash Glow Fade\").visible = false;\n\t\tthisScene.getLayer(\"Masked Sky Glow\").visible = false;\n\t}\n}\n\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorClick(event) {\n\tswitch (activePhase) {\n\tcase ScenePhase.SPLASH:\n\t\t// shared.timeNudge = ScenePhase.SPLASH.length - phaseTime;\n\t\t// phaseTime = ScenePhase.SPLASH.length;\n\t\tbreak;\n\tcase ScenePhase.MAIN.INTRO:\n\t\t// if (phaseTime < 0.6) {\n\t\t// \tAudioManager.playSound(\"logo-instant-bling-quick.ogg\")\n\t\t// \tshared.timeNudge = 0.6 - phaseTime;\n\t\t// \tphaseTime = 0.6;\n\t\t// }\n\t\tbreak;\n\t}\n}\n",
				"scriptproperties" : 
				{
					"debug_ScenePhase" : false
				},
				"value" : false
			}
		},
		{
			"angles" : "0.00000 0.00000 0.00000",
			"id" : 23,
			"locktransforms" : true,
			"maxtime" : 5.0,
			"mintime" : 1.0,
			"muteineditor" : true,
			"name" : "Silence (Enables volume slider)",
			"origin" : "-100.00000 -100.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"playbackmode" : "loop",
			"scale" : "1.00000 1.00000 1.00000",
			"sound" : [],
			"startsilent" : true,
			"volume" : 0.5
		},
		{
			"alignment" : "topleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 16,
			"image" : "models/Sky.json",
			"ledsource" : true,
			"locktransforms" : false,
			"name" : "Sky",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(0, shared.screenBoundsY.y + Math.floor(900 - shared.viewportY * 0.66) * shared.canvasToScreen, 0);\n}\n",
				"value" : "0.00000 1980.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\nexport function init(value) {\n\tresizeScreen();\n}\nexport function resizeScreen() {\n\tthisLayer.scale = new Vec3(engine.canvasSize.x, ((900 - 360) * shared.canvasToScreen + shared.screenBoundsY.y) / 264, 1);\n}",
				"value" : "1920.00000 6.13630 1.00000"
			},
			"size" : "1.00000 264.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "topleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 285,
			"image" : "models/Stars.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Stars",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(shared.screenBoundsX.x - 30 * shared.canvasToScreen, shared.screenBoundsY.y + (1080 - shared.viewportY * 0.66) * shared.canvasToScreen, 0);\n}\n",
				"value" : "0.00000 1080.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tthisLayer.scale = new Vec3(4 * shared.canvasToScreen);\n}\n",
				"value" : "4.00000 4.00000 4.00000"
			},
			"size" : "638.00000 195.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 193,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Big Clouds (script)",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nlet Helpers = shared.OMGHelpers;\n\n/** \n * Array containing the small cloud image layers.\n * @type ILayer[] \n */\nlet clouds = [];\n/**\n * The maximum number of clouds we will spawn. Can vary based on the screen resolution.\n */\nlet maxClouds = undefined;\n\n/** How quickly the clouds move across the screen. */\nlet cloudSpeed = -6;\n\n/** The width of the largest cloud. Used to determine when clouds fall off-screen and despawn. */\nlet cloudWidth = 1536;\n\nlet a_cloud1 = engine.registerAsset(\"models/BigCloud.json\");\n\n/**\n *  Creates a small cloud at the specified position.\n * @param {number} position - The initial x coordinate of the cloud\n * @return {ILayer} - The newly created cloud layer.\n */\nfunction createCloud(position) {\n\tlet imagePath = undefined;\n\tlet newLayer = undefined;\n\tclouds.push(newLayer = thisScene.createLayer({\n\t\timage : \"models/BigCloud.json\",\n\t\tname : \"SmallCloud1\",\n\t\tscale : new Vec3(3 * shared.canvasToScreen),\n\t\torigin : new Vec3(\n\t\t\tposition,\n\t\t\t750 * shared.canvasToScreen - shared.viewportY * 0.5,\n\t\t\t0),\n\t\talignment : \"top\"\n\t}));\n\tthisScene.sortLayer(newLayer, thisScene.getLayerIndex(thisLayer));\n\treturn \n}\n\nexport function init() {\n\tresizeScreen();\n\n\tfor (let i = 0; i < maxClouds; ++i)\n\t\tcreateCloud(Math.random() * (shared.screenBoundsX.y - shared.screenBoundsX.x + cloudWidth * shared.canvasToScreen) - cloudWidth * 0.5 * shared.canvasToScreen);\n}\n\nexport function resizeScreen() {\n\tmaxClouds = Math.floor(Math.max(1, engine.screenResolution.x * engine.screenResolution.y / 1200000));\n\n\tfor (let cloud of clouds)\n\t\tcloud.scale = new Vec3(3 * shared.canvasToScreen);\n}\n\n\nexport function update() {\n\tfor (let i in clouds) {\n\t\tlet cloud = clouds[i];\n\t\tcloud.origin = new Vec3(cloud.origin.x + cloudSpeed * engine.frametime, 750 * shared.canvasToScreen - shared.viewportY * 0.5, cloud.origin.z);\n\t\tif (cloud.origin.x < shared.screenBoundsX.x - cloudWidth * 0.5 * shared.canvasToScreen) {\n\t\t\tthisScene.destroyLayer(cloud);\n\t\t\tclouds.splice(i, 1);\n\t\t}\n\t}\n\twhile (clouds.length < maxClouds)\n\t\tcreateCloud(shared.screenBoundsX.y + cloudWidth * 0.5 * shared.canvasToScreen + Math.random() * 100);\n}\n",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 194,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Small Clouds (script)",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nlet Helpers = shared.OMGHelpers;\n\n/** \n * Array containing the small cloud image layers.\n * @type ILayer[] \n */\nlet clouds = [];\n/**\n * The maximum number of clouds we will spawn. Can vary based on the screen resolution.\n */\nlet maxClouds = undefined;\n\n/** How quickly the clouds move across the screen. */\nlet cloudSpeed = -18;\n\n/** The width of the largest cloud. Used to determine when clouds fall off-screen and despawn. */\nlet cloudWidth = 447;\n\nlet a_cloud1 = engine.registerAsset(\"models/SmallCloud1.json\");\nlet a_cloud2 = engine.registerAsset(\"models/SmallCloud2.json\");\nlet a_cloud3 = engine.registerAsset(\"models/SmallCloud3.json\");\n\n/**\n *  Creates a small cloud at the specified position.\n * @param {number} position - The initial x coordinate of the cloud\n * @return {ILayer} - The newly created cloud layer.\n */\nfunction createCloud(position) {\n\tlet imagePath = undefined;\n\tlet newLayer = undefined;\n\tswitch (Math.floor(Math.random() * 3)) {\n\t\tcase 0:\n\t\t\timagePath = \"models/SmallCloud1.json\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\timagePath = \"models/SmallCloud2.json\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\tdefault:\n\t\t\timagePath = \"models/SmallCloud3.json\";\n\t\t\tbreak;\n\t}\n\tclouds.push(newLayer = thisScene.createLayer({\n\t\timage : imagePath,\n\t\tname : \"SmallCloud1\",\n\t\tscale : new Vec3(3 * shared.canvasToScreen),\n\t\torigin : new Vec3(\n\t\t\tposition,\n\t\t\t900 * shared.canvasToScreen + Math.random() * (shared.screenBoundsY.y - shared.screenBoundsY.x) * 0.5,\n\t\t\t0)\n\t}));\n\tthisScene.sortLayer(newLayer, thisScene.getLayerIndex(thisLayer));\n\tnewLayer.height = newLayer.origin.y;\n\treturn \n}\n\nexport function init() {\n\tresizeScreen();\n\n\tfor (let i = 0; i < maxClouds; ++i)\n\t\tcreateCloud(Math.random() * (shared.screenBoundsX.y - shared.screenBoundsX.x + cloudWidth * shared.canvasToScreen) - cloudWidth * 0.5 * shared.canvasToScreen);\n}\n\nexport function resizeScreen() {\n\tmaxClouds = Math.floor(engine.screenResolution.x * engine.screenResolution.y / 120000);\n\n\tfor (let cloud of clouds)\n\t\tcloud.scale = new Vec3(3 * shared.canvasToScreen);\n}\n\n\nexport function update() {\n\tfor (let i in clouds) {\n\t\tlet cloud = clouds[i];\n\t\tcloud.origin = new Vec3(cloud.origin.x + cloudSpeed * engine.frametime, cloud.height - shared.viewportY * 0.5, cloud.origin.z);\n\t\tif (cloud.origin.x < shared.screenBoundsX.x - cloudWidth * 0.5 * shared.canvasToScreen) {\n\t\t\tthisScene.destroyLayer(cloud);\n\t\t\tclouds.splice(i, 1);\n\t\t}\n\t}\n\twhile (clouds.length < maxClouds)\n\t\tcreateCloud(shared.screenBoundsX.y + cloudWidth * 0.5 * shared.canvasToScreen + Math.random() * 100);\n}\n",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 267,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Sky Capture",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "bottomleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/transform/effect.json",
					"id" : 65,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"angle" : 0.0,
								"offset" : "0 0",
								"scale" : "5 1"
							},
							"id" : 66
						}
					],
					"visible" : true
				}
			],
			"id" : 81,
			"image" : "models/Hills2.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Background Hills",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(shared.screenBoundsX.x - 90 * shared.canvasToScreen, shared.screenBoundsY.x + (30 - shared.viewportY * 0.66) * shared.canvasToScreen, 0);\n}",
				"value" : "-90.00000 30.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tthisLayer.scale = new Vec3(5 * 3 * shared.canvasToScreen, 3 * shared.canvasToScreen, 1);\n}\n",
				"value" : "15.00000 3.00000 3.00000"
			},
			"size" : "639.00000 148.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "bottomleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.1,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/transform/effect.json",
					"id" : 61,
					"name" : "",
					"passes" : 
					[
						{
							"combos" : 
							{
								"CLAMP" : 1,
								"MODE" : 0
							},
							"constantshadervalues" : 
							{
								"angle" : 0.0,
								"offset" : "0 0",
								"scale" : "5 1"
							},
							"id" : 62
						}
					],
					"visible" : true
				}
			],
			"id" : 85,
			"image" : "models/Hills1.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Foreground Hills",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(shared.screenBoundsX.x, shared.screenBoundsY.x - shared.viewportY * shared.canvasToScreen, 0);\n}",
				"value" : "0.00000 0.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tthisLayer.scale = new Vec3(5 * 3 * shared.canvasToScreen, 3 * shared.canvasToScreen, 1);\n}\n",
				"value" : "15.00000 3.00000 3.00000"
			},
			"size" : "639.00000 148.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 332,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Scene Capture",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"dependencies" : [ 267 ],
			"effects" : 
			[
				{
					"file" : "effects/blend/effect.json",
					"id" : 264,
					"name" : "Subtract Sky from final scene",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 18,
								"NUMBLENDTEXTURES" : 1,
								"TRANSFORMUV" : 0
							},
							"constantshadervalues" : 
							{
								"blendoffset" : "0 0",
								"multiply" : 1
							},
							"id" : 265,
							"textures" : [ null, "_rt_imageLayerComposite_267_a" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/tint/effect.json",
					"id" : 514,
					"name" : "Desaturate",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 27
							},
							"constantshadervalues" : 
							{
								"alpha" : 1.0,
								"color" : "1 1 1"
							},
							"id" : 515
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/tint/effect.json",
					"id" : 296,
					"name" : "Multiply to create binary mask",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 11
							},
							"constantshadervalues" : 
							{
								"alpha" : 99999,
								"color" : "1 1 1"
							},
							"id" : 297
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blend/effect.json",
					"id" : 281,
					"name" : "Invert (Final Sky Mask)",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 19,
								"WRITEALPHA" : 0
							},
							"constantshadervalues" : 
							{
								"multiply" : 1
							},
							"id" : 282,
							"textures" : [ null, "util/white" ]
						}
					],
					"visible" : true
				}
			],
			"id" : 262,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Sky Mask",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"dependencies" : [ 262, 267, 332 ],
			"effects" : 
			[
				{
					"file" : "effects/blend/effect.json",
					"id" : 371,
					"name" : "Get Sky Mask",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 0
							},
							"constantshadervalues" : 
							{
								"multiply" : 1.0
							},
							"id" : 372,
							"textures" : [ null, "_rt_imageLayerComposite_262_a" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blend/effect.json",
					"id" : 260,
					"name" : "Multiply mask with sky capture",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"multiply" : 1.0
							},
							"id" : 275,
							"textures" : [ null, "_rt_imageLayerComposite_267_a" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blur/effect.json",
					"id" : 276,
					"name" : "",
					"passes" : 
					[
						{
							"id" : 277
						},
						{
							"constantshadervalues" : 
							{
								"scale" : "15 15"
							},
							"id" : 278
						},
						{
							"combos" : 
							{
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "15 15"
							},
							"id" : 283
						},
						{
							"constantshadervalues" : 
							{
								"compositecolor" : "1 1 1"
							},
							"id" : 284,
							"textures" : [ null, "util/white", "_rt_imageLayerComposite_238_b" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blur/effect.json",
					"id" : 286,
					"name" : "",
					"passes" : 
					[
						{
							"id" : 287
						},
						{
							"combos" : 
							{
								"KERNEL" : 2
							},
							"constantshadervalues" : 
							{
								"scale" : "10 10"
							},
							"id" : 288
						},
						{
							"combos" : 
							{
								"KERNEL" : 2,
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "10 10"
							},
							"id" : 289
						},
						{
							"constantshadervalues" : 
							{
								"compositecolor" : "1 1 1"
							},
							"id" : 290,
							"textures" : [ null, "util/white", "_rt_imageLayerComposite_238_a" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/tint/effect.json",
					"id" : 291,
					"name" : "Increase Saturation",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 27
							},
							"constantshadervalues" : 
							{
								"alpha" : 1,
								"color" : "0.7725490196078432 0.2627450980392157 0.2627450980392157"
							},
							"id" : 292
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blend/effect.json",
					"id" : 293,
					"name" : "Add to scene",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 9,
								"WRITEALPHA" : 1
							},
							"constantshadervalues" : 
							{
								"alpha" : 0.40000001,
								"multiply" : 1
							},
							"id" : 294,
							"textures" : [ null, "_rt_imageLayerComposite_332_a" ]
						}
					],
					"visible" : false
				}
			],
			"id" : 238,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Sky Glow",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"dependencies" : [ 238, 262, 332 ],
			"effects" : 
			[
				{
					"file" : "effects/blend/effect.json",
					"id" : 438,
					"name" : "Get Sky Mask",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 0
							},
							"constantshadervalues" : 
							{
								"multiply" : 1.0
							},
							"id" : 439,
							"textures" : [ null, "_rt_imageLayerComposite_262_a" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blend/effect.json",
					"id" : 488,
					"name" : "Invert (Final Sky Mask)",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 19,
								"WRITEALPHA" : 0
							},
							"constantshadervalues" : 
							{
								"multiply" : 1
							},
							"id" : 0,
							"textures" : [ null, "util/white" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blend/effect.json",
					"id" : 445,
					"name" : "Multiply mask with Sky Glow",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"multiply" : 1.0
							},
							"id" : 446,
							"textures" : [ null, "_rt_imageLayerComposite_238_a" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/blend/effect.json",
					"id" : 459,
					"name" : "Add to scene",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 9,
								"WRITEALPHA" : 1
							},
							"constantshadervalues" : 
							{
								"alpha" : 0.55000001,
								"multiply" : 1
							},
							"id" : 460,
							"textures" : [ null, "_rt_imageLayerComposite_332_a" ]
						}
					],
					"visible" : true
				}
			],
			"id" : 437,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Masked Sky Glow",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "bottomleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 57,
			"image" : "models/Leaves_Left.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Leaves_Left",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(shared.screenBoundsX.x, shared.screenBoundsY.x - shared.viewportY * 2, 0);\n}\n",
				"value" : "0.00000 0.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tresizeScreen();\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "164.00000 142.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "bottomright",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 114,
			"image" : "models/Leaves_Right.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Leaves_Right",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(shared.screenBoundsX.y, shared.screenBoundsY.x - shared.viewportY * 2, 0);\n}\n",
				"value" : "1920.00000 0.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tresizeScreen();\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "122.00000 153.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 178,
			"image" : "models/Bird.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Bird",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(value.x, shared.screenBoundsY.x + (390 - shared.viewportY * 2.0) * shared.canvasToScreen, value.z);\n}\n",
				"value" : "1710.00000 390.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "26.00000 26.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 183,
			"image" : "models/Bird.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Bird 2",
			"origin" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn new Vec3(value.x, shared.screenBoundsY.x + (360 - shared.viewportY * 2.0) * shared.canvasToScreen, value.z);\n}\n",
				"value" : "1820.00000 360.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "26.00000 26.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Boolean} value - for property 'visible'\n * @return {Boolean} - update current property value\n */\nexport function init(value) {\n\tthisLayer.getTextureAnimation().setFrame(1);\n}\n",
				"value" : true
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 76,
			"image" : "models/TitleCard.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "TitleCard",
			"origin" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tlet x = shared.globalXOffset * shared.canvasToScreen + engine.canvasSize.x / 2.0;\n\tlet y = shared.screenBoundsY.y + ((300 * shared.zoom) - shared.viewportY / 3.0 * shared.zoom - (93 * shared.zoom)) * shared.canvasToScreen;\n\n\treturn new Vec3(x, y, 0);\n}\n",
				"value" : "960.00000 827.26440 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tthisLayer.scale = new Vec3(shared.zoom * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(shared.zoom * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tthisLayer.scale = new Vec3(shared.zoom * shared.canvasToScreen * shared.ui_scale);\n}\n",
				"value" : "2.00000 2.00000 2.00000"
			},
			"size" : "400.00000 187.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "topleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 153,
			"image" : "models/Title_New.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Title_New",
			"origin" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tlet buttonWidth = thisLayer.size.x * thisLayer.scale.x;\n\tlet buttonHeight = thisLayer.size.y * thisLayer.scale.y;\n\tlet numButtons = 4;\n\tlet spacing = 24;\n\n\tlet x = engine.canvasSize.x / 2.0;\n\tx -= buttonWidth * numButtons / 2;\n\tx -= spacing * (numButtons - 1) * shared.canvasToScreen / 2;\n\tx += 0 * (buttonWidth + spacing * shared.canvasToScreen);\n\tlet y = shared.screenBoundsY.x + (buttonHeight + 24 * shared.canvasToScreen);\n\n\treturn new Vec3(x, y, 0);\n}\n",
				"value" : "493.51489 231.23755 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tresizeScreen();\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tresizeScreen();\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "74.00000 58.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "topleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 156,
			"image" : "models/Title_Load.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Title_Load",
			"origin" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tlet buttonWidth = thisLayer.size.x * thisLayer.scale.x;\n\tlet buttonHeight = thisLayer.size.y * thisLayer.scale.y;\n\tlet numButtons = 4;\n\tlet spacing = 24;\n\n\tlet x = engine.canvasSize.x / 2.0;\n\tx -= buttonWidth * numButtons / 2;\n\tx -= spacing * (numButtons - 1) * shared.canvasToScreen / 2;\n\tx += 1 * (buttonWidth + spacing * shared.canvasToScreen);\n\tlet y = shared.screenBoundsY.x + (buttonHeight + 24 * shared.canvasToScreen);\n\n\treturn new Vec3(x, y, 0);\n}\n",
				"value" : "731.43555 229.90094 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tresizeScreen();\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tresizeScreen();\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "74.00000 58.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "topleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 164,
			"image" : "models/Title_Coop.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Title_Coop",
			"origin" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tlet buttonWidth = thisLayer.size.x * thisLayer.scale.x;\n\tlet buttonHeight = thisLayer.size.y * thisLayer.scale.y;\n\tlet numButtons = 4;\n\tlet spacing = 24;\n\n\tlet x = engine.canvasSize.x / 2.0;\n\tx -= buttonWidth * numButtons / 2;\n\tx -= spacing * (numButtons - 1) * shared.canvasToScreen / 2;\n\tx += 2 * (buttonWidth + spacing * shared.canvasToScreen);\n\tlet y = shared.screenBoundsY.x + (buttonHeight + 24 * shared.canvasToScreen);\n\n\treturn new Vec3(x, y, 0);\n}\n",
				"value" : "969.35651 231.23767 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tresizeScreen();\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tresizeScreen();\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "74.00000 58.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "topleft",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 170,
			"image" : "models/Title_Exit.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Title_Exit",
			"origin" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tlet buttonWidth = thisLayer.size.x * thisLayer.scale.x;\n\tlet buttonHeight = thisLayer.size.y * thisLayer.scale.y;\n\tlet numButtons = 4;\n\tlet spacing = 24;\n\n\tlet x = engine.canvasSize.x / 2.0;\n\tx -= buttonWidth * numButtons / 2;\n\tx -= spacing * (numButtons - 1) * shared.canvasToScreen / 2;\n\tx += 3 * (buttonWidth + spacing * shared.canvasToScreen);\n\tlet y = shared.screenBoundsY.x + (buttonHeight + 24 * shared.canvasToScreen);\n\n\treturn new Vec3(x, y, 0);\n}\n",
				"value" : "1205.29211 232.78934 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tresizeScreen();\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tresizeScreen();\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "74.00000 58.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/blur/effect.json",
					"id" : 234,
					"name" : "",
					"passes" : 
					[
						{
							"id" : 242
						},
						{
							"combos" : 
							{
								"KERNEL" : 2
							},
							"constantshadervalues" : 
							{
								"scale" : "1 1"
							},
							"id" : 243
						},
						{
							"combos" : 
							{
								"KERNEL" : 2,
								"VERTICAL" : 1
							},
							"constantshadervalues" : 
							{
								"scale" : "1 1"
							},
							"id" : 244
						},
						{
							"combos" : 
							{
								"BLENDMODE" : 9,
								"COMPOSITE" : 1,
								"COMPOSITEMONO" : 1
							},
							"constantshadervalues" : 
							{
								"compositealpha" : 
								{
									"script" : "'use strict';\n\n/**\n * @param {Number} value - for property 'compositealpha'\n * @return {Number} - update current property value\n */\nexport function update(value) {\n\t// return thisScene.getLayer(\"Splash White Fade\").alpha * 4;\n}\n",
									"value" : 0
								},
								"compositecolor" : "1 1 1",
								"compositeoffset" : "0 0"
							},
							"id" : 245,
							"textures" : [ null, "util/white", "_rt_imageLayerComposite_233_a" ]
						}
					],
					"visible" : true
				}
			],
			"id" : 233,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Splash Glow Fade",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "center",
			"alpha" : 0.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 35,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Splash White Fade",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "1920.00000 1080.00000",
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "right",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 38,
			"image" : "models/ConcernedApe_1.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "ConcernedApe Closed Eyes",
			"origin" : "955.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "85.00000 69.00000",
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "right",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 141,
			"image" : "models/ConcernedApe_2.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "ConcernedApe Sunglasses",
			"origin" : "955.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "85.00000 69.00000",
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "left",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 42,
			"image" : "models/ConcernedApe_4.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "ConcernedApe Text",
			"origin" : "965.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tthisLayer.scale = new Vec3(3 * shared.canvasToScreen * shared.ui_scale);\n}\n",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "111.00000 57.00000",
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "center",
			"alpha" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\nlet minAlpha = 0.05;\nlet maxAlpha = 0.75;\nlet fadeTime = 0.25;\nlet mouseHover = false;\n\n/**\n * @param {Number} value - for property 'alpha'\n * @return {Number} - update current property value\n */\nexport function update(value) {\n\tif (!mouseHover)\n\t\tthisLayer.alpha -= (maxAlpha - minAlpha) / fadeTime * engine.frametime;\n\telse\n\t\tthisLayer.alpha += (maxAlpha - minAlpha) / fadeTime * engine.frametime * 5.0;\n\tthisLayer.alpha = Helpers.clamp(thisLayer.alpha, minAlpha, maxAlpha);\n}\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorEnter(event) {\n\tmouseHover = true;\n}\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorLeave(event) {\n\tmouseHover = false;\n}",
				"value" : 0.050000001
			},
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 134,
			"image" : "models/Skip.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Skip Button",
			"origin" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tresizeScreen();\n}\n\nexport function resizeScreen() {\n\tthisLayer.origin = new Vec3(shared.screenBoundsX.y - 45, shared.screenBoundsY.x + 35, 0);\n}\n",
				"value" : "1900.00000 20.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\nlet fadeTime = 0.25;\nlet minScale = 3.0;\nlet maxScale = 3.5;\nlet minAlpha = 0.075;\nlet maxAlpha = 0.75;\n\nlet mouseHover = false;\n\n/**\n * @param {Number} value - for property 'alpha'\n * @return {Number} - update current property value\n */\nexport function update(value) {\n\tif (!mouseHover) {\n\t\tthisLayer.alpha -= (maxAlpha - minAlpha) / fadeTime * engine.frametime;\n\t\tthisLayer.scale = new Vec3(thisLayer.scale.x - (maxScale - minScale) * shared.canvasToScreen / fadeTime * engine.frametime);\n\t}\n\telse {\n\t\tthisLayer.alpha += (maxAlpha - minAlpha) / fadeTime * engine.frametime * 5.0;\n\t\tthisLayer.scale = new Vec3(thisLayer.scale.x + (maxScale - minScale) * shared.canvasToScreen / fadeTime * engine.frametime * 5.0);\n\t}\n\tthisLayer.alpha = Helpers.clamp(thisLayer.alpha, minAlpha, maxAlpha);\n\tthisLayer.scale = Helpers.clamp(thisLayer.scale, new Vec3(minScale * shared.canvasToScreen), new Vec3(maxScale * shared.canvasToScreen));\n}\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function init(value) {\n\treturn new Vec3(minScale * shared.canvasToScreen);\n}\n\n/**\n * @param {Vec2} size\n */\nexport function resizeScreen(size) {\n\tthisLayer.scale = new Vec3(minScale * shared.canvasToScreen);\n}\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorEnter(event) {\n\tmouseHover = true;\n}\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorLeave(event) {\n\tmouseHover = false;\n}",
				"value" : "3.00000 3.00000 3.00000"
			},
			"size" : "22.00000 15.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorClick(event) {\n\tshared.SceneManager.skipPressed();\n}\n",
				"value" : true
			}
		},
		{
			"alignment" : "center",
			"alpha" : 0.2,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 0.00000 0.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 146,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Screenbounds (unused)",
			"origin" : "960.00000 540.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'scale'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tlet boundsX = new Vec2(0, engine.canvasSize.x);\n\tlet boundsY = new Vec2(0, engine.canvasSize.y);\n\tlet screenAspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\tlet canvasAspectRatio = engine.canvasSize.x / engine.canvasSize.y;\n\tif (screenAspectRatio > canvasAspectRatio) {\n\t\tlet height = engine.screenResolution.y * engine.canvasSize.x / engine.screenResolution.x;\n\t\tlet cornerOffset = (engine.canvasSize.y - height) / 2;\n\t\tboundsY = new Vec2(cornerOffset, engine.canvasSize.y - cornerOffset);\n\t}\n\telse {\n\t\tlet width = engine.screenResolution.x * engine.canvasSize.y / engine.screenResolution.y;\n\t\tlet cornerOffset = (engine.canvasSize.x - width) / 2;\n\t\tboundsX = new Vec2(cornerOffset, engine.canvasSize.x - cornerOffset);\n\t}\n\n\tthisLayer.scale = new Vec3(boundsX.y - boundsX.x, boundsY.y - boundsY.x);\n\t// if (engine.screenResolution.x / engine.canvasSize.x > engine.screenResolution.y / engine.canvasSize.y)\n\t// \tthisLayer.scale = new Vec3(engine.canvasSize.x, engine.canvasSize.y / shared.canvasToScreen, 1);\n\t// else\n\t// \tthisLayer.scale = new Vec3(engine.canvasSize.x / shared.canvasToScreen, engine.canvasSize.y, 1);\n}\n",
				"value" : "1.00000 1.00000 1.00000"
			},
			"size" : "1.00000 1.00000",
			"solid" : true,
			"visible" : false
		},
		{
			"alignment" : "center",
			"alpha" : 0.5,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "0.43137 1.00000 0.36863",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 331,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Leaf_Clickbox_1",
			"origin" : "684.58820 714.99475 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "34.00000 58.00000 1.00000",
			"size" : "1.00000 1.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nlet LayerParenting = shared.LayerParenting;\nlet Helpers = shared.OMGHelpers;\nlet PARENTFLAG = shared.PARENTFLAG;\n\nexport function init() {\n\tlet titleCard = thisScene.getLayer(\"TitleCard\");\n\tlet originalScale = titleCard.scale; // Store current scale of Title Card\n\ttitleCard.scale = new Vec3(2, 2, 2); // Set Title Card scale to 2 temporarily, so it matches the reference\n\tLayerParenting.setParent(thisLayer, titleCard, PARENTFLAG.ALL);\n\ttitleCard.scale = originalScale; // Restore original scale of Title Card.\n}\n\n/**\n * @param {ICursorEvent} event\n */\nexport function cursorClick(event) {\n\t// Spawn falling leaf particles\n}\n",
				"value" : false
			}
		}
	],
	"version" : 1
}